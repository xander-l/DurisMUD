/*
 * ************************************************************************
 * *   File: graph.c                                       Part of CircleMUD 
 * * *  Usage: various graph algorithms
 *   * *
 *     * *  All rights reserved.  See license.doc for complete information.
 *       * *
 *         * *  Copyright (C) 1993 by the Trustees of the Johns Hopkins
 * University     * *  CircleMUD is based on DikuMUD, Copyright (C) 1990,
 * 1991.               *
 * ************************************************************************ 
 */

/*
CHANGELOG
------------
2006.3.22 - added dijkstra's algorithm to path finding functions (torgal)


*/

#define TRACK_THROUGH_DOORS

/*
 * You can define or not define TRACK_THOUGH_DOORS, above, depending on
 * whether or not you want track to find paths which lead through closed
 * or hidden doors. 
 */

#include <stdio.h>
#include "defines.h"

#ifdef __CYGWIN32__
#   include <mingw/values.h>
#else
#   ifdef _FREEBSD
#      include <libguile/values.h>
#   else
//#      include <values.h>
#   endif
#endif
#include <string.h>

#include <vector>
#include <list>
#include <queue>
using namespace std;

#include "structs.h"
#include "utils.h"
#include "prototypes.h"
#include "graph.h"
#include "utils.h"
#include "mm.h"
#include "map.h"

static void bfs_enqueue(int room, int dir, int step);
static void bfs_dequeue(void);
static void bfs_clear_queue(void);

/*
 * Externals 
 */
extern int top_of_world;
extern const char *dirs[];
extern const char *short_dirs[];
extern P_room world;
extern const char *command[];
extern struct zone_data *zone_table;
extern P_index mob_index;

const int distance_array[MAX_AXIS_INDEX][MAX_AXIS_INDEX][MAX_AXIS_INDEX] = 
{
  {
    {
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
    },
    {
      1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
    },
    {
      2, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
    },
    {
      3, 3, 4, 4, 5, 6, 7, 8, 9, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
    },
    {
      4, 4, 4, 5, 6, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16, 17, 18, 19
    },
    {
      5, 5, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
    },
    {
      6, 6, 6, 7, 7, 8, 8, 9, 10, 11, 12, 13, 13, 14, 15, 16, 17, 18, 19, 20
    },
    {
      7, 7, 7, 8, 8, 9, 9, 10, 11, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20
    },
    {
      8, 8, 8, 9, 9, 9, 10, 11, 11, 12, 13, 14, 14, 15, 16, 17, 18, 19, 20, 21
    },
    {
      9, 9, 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 15, 16, 17, 17, 18, 19, 20, 21
    },
    {
      10, 10, 10, 10, 11, 11, 12, 12, 13, 13, 14, 15, 16, 16, 17, 18, 19, 20, 21, 21
    },
    {
      11, 11, 11, 11, 12, 12, 13, 13, 14, 14, 15, 16, 16, 17, 18, 19, 19, 20, 21, 22
    },
    {
      12, 12, 12, 12, 13, 13, 13, 14, 14, 15, 16, 16, 17, 18, 18, 19, 20, 21, 22, 22
    },
    {
      13, 13, 13, 13, 14, 14, 14, 15, 15, 16, 16, 17, 18, 18, 19, 20, 21, 21, 22, 23
    },
    {
      14, 14, 14, 14, 15, 15, 15, 16, 16, 17, 17, 18, 18, 19, 20, 21, 21, 22, 23, 24
    },
    {
      15, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 19, 19, 20, 21, 21, 22, 23, 23, 24
    },
    {
      16, 16, 16, 16, 16, 17, 17, 17, 18, 18, 19, 19, 20, 21, 21, 22, 23, 23, 24, 25
    },
    {
      17, 17, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25, 25
    },
    {
      18, 18, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26
    },
    {
      19, 19, 19, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 23, 24, 24, 25, 25, 26, 27
    },

  },
  {
    {
      1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
    },
    {
      1, 2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
    },
    {
      2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
    },
    {
      3, 3, 4, 4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
    },
    {
      4, 4, 5, 5, 6, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19
    },
    {
      5, 5, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
    },
    {
      6, 6, 6, 7, 7, 8, 9, 9, 10, 11, 12, 13, 13, 14, 15, 16, 17, 18, 19, 20
    },
    {
      7, 7, 7, 8, 8, 9, 9, 10, 11, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20
    },
    {
      8, 8, 8, 9, 9, 9, 10, 11, 11, 12, 13, 14, 14, 15, 16, 17, 18, 19, 20, 21
    },
    {
      9, 9, 9, 10, 10, 10, 11, 11, 12, 13, 13, 14, 15, 16, 17, 18, 18, 19, 20, 21
    },
    {
      10, 10, 10, 10, 11, 11, 12, 12, 13, 13, 14, 15, 16, 16, 17, 18, 19, 20, 21, 21
    },
    {
      11, 11, 11, 11, 12, 12, 13, 13, 14, 14, 15, 16, 16, 17, 18, 19, 19, 20, 21, 22
    },
    {
      12, 12, 12, 12, 13, 13, 13, 14, 14, 15, 16, 16, 17, 18, 18, 19, 20, 21, 22, 22
    },
    {
      13, 13, 13, 13, 14, 14, 14, 15, 15, 16, 16, 17, 18, 18, 19, 20, 21, 21, 22, 23
    },
    {
      14, 14, 14, 14, 15, 15, 15, 16, 16, 17, 17, 18, 18, 19, 20, 21, 21, 22, 23, 24
    },
    {
      15, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 21, 21, 22, 23, 23, 24
    },
    {
      16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 19, 19, 20, 21, 21, 22, 23, 23, 24, 25
    },
    {
      17, 17, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25, 26
    },
    {
      18, 18, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26
    },
    {
      19, 19, 19, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 23, 24, 24, 25, 26, 26, 27
    },

  },
  {
    {
      2, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
    },
    {
      2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
    },
    {
      3, 3, 3, 4, 5, 6, 7, 8, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
    },
    {
      4, 4, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 13, 14, 15, 16, 17, 18, 19
    },
    {
      4, 5, 5, 5, 6, 7, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
    },
    {
      5, 5, 6, 6, 7, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
    },
    {
      6, 6, 7, 7, 7, 8, 9, 9, 10, 11, 12, 13, 14, 14, 15, 16, 17, 18, 19, 20
    },
    {
      7, 7, 8, 8, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 16, 17, 18, 18, 19, 20
    },
    {
      8, 8, 8, 9, 9, 10, 10, 11, 11, 12, 13, 14, 15, 15, 16, 17, 18, 19, 20, 21
    },
    {
      9, 9, 9, 10, 10, 10, 11, 12, 12, 13, 14, 14, 15, 16, 17, 18, 18, 19, 20, 21
    },
    {
      10, 10, 10, 11, 11, 11, 12, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19, 20, 21, 22
    },
    {
      11, 11, 11, 12, 12, 12, 13, 13, 14, 14, 15, 16, 16, 17, 18, 19, 20, 20, 21, 22
    },
    {
      12, 12, 12, 13, 13, 13, 14, 14, 15, 15, 16, 16, 17, 18, 19, 19, 20, 21, 22, 23
    },
    {
      13, 13, 13, 13, 14, 14, 14, 15, 15, 16, 17, 17, 18, 18, 19, 20, 21, 21, 22, 23
    },
    {
      14, 14, 14, 14, 15, 15, 15, 16, 16, 17, 17, 18, 19, 19, 20, 21, 21, 22, 23, 24
    },
    {
      15, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 21, 21, 22, 23, 24, 24
    },
    {
      16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25
    },
    {
      17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25, 26
    },
    {
      18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25, 26, 26
    },
    {
      19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 26, 26, 27
    },

  },
  {
    {
      3, 3, 4, 4, 5, 6, 7, 8, 9, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
    },
    {
      3, 3, 4, 4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
    },
    {
      4, 4, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 13, 14, 15, 16, 17, 18, 19
    },
    {
      4, 4, 5, 5, 6, 7, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 18, 19
    },
    {
      5, 5, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
    },
    {
      6, 6, 6, 7, 7, 8, 8, 9, 10, 11, 12, 12, 13, 14, 15, 16, 17, 18, 19, 20
    },
    {
      7, 7, 7, 7, 8, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 16, 17, 18, 19, 20
    },
    {
      8, 8, 8, 8, 9, 9, 10, 10, 11, 12, 13, 13, 14, 15, 16, 17, 18, 19, 20, 20
    },
    {
      9, 9, 9, 9, 9, 10, 10, 11, 12, 12, 13, 14, 15, 16, 16, 17, 18, 19, 20, 21
    },
    {
      9, 10, 10, 10, 10, 11, 11, 12, 12, 13, 14, 15, 15, 16, 17, 18, 19, 19, 20, 21
    },
    {
      10, 10, 11, 11, 11, 12, 12, 13, 13, 14, 14, 15, 16, 17, 17, 18, 19, 20, 21, 22
    },
    {
      11, 11, 12, 12, 12, 12, 13, 13, 14, 15, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22
    },
    {
      12, 12, 13, 13, 13, 13, 14, 14, 15, 15, 16, 17, 17, 18, 19, 19, 20, 21, 22, 23
    },
    {
      13, 13, 13, 14, 14, 14, 15, 15, 16, 16, 17, 17, 18, 19, 19, 20, 21, 22, 22, 23
    },
    {
      14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 19, 19, 20, 21, 21, 22, 23, 24
    },
    {
      15, 15, 15, 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 21, 21, 22, 23, 24, 24
    },
    {
      16, 16, 16, 17, 17, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 23, 24, 24, 25
    },
    {
      17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 20, 20, 21, 22, 22, 23, 24, 24, 25, 26
    },
    {
      18, 18, 18, 18, 19, 19, 19, 20, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25, 26, 26
    },
    {
      19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 26, 26, 27
    },

  },
  {
    {
      4, 4, 4, 5, 6, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16, 17, 18, 19
    },
    {
      4, 4, 5, 5, 6, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19
    },
    {
      4, 5, 5, 5, 6, 7, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
    },
    {
      5, 5, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
    },
    {
      6, 6, 6, 6, 7, 8, 8, 9, 10, 11, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
    },
    {
      6, 6, 7, 7, 8, 8, 9, 9, 10, 11, 12, 13, 14, 14, 15, 16, 17, 18, 19, 20
    },
    {
      7, 7, 7, 8, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 16, 17, 18, 18, 19, 20
    },
    {
      8, 8, 8, 9, 9, 9, 10, 11, 11, 12, 13, 14, 14, 15, 16, 17, 18, 19, 20, 21
    },
    {
      9, 9, 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 15, 16, 17, 17, 18, 19, 20, 21
    },
    {
      10, 10, 10, 10, 11, 11, 12, 12, 13, 13, 14, 15, 16, 16, 17, 18, 19, 20, 21, 21
    },
    {
      11, 11, 11, 11, 11, 12, 12, 13, 13, 14, 15, 15, 16, 17, 18, 18, 19, 20, 21, 22
    },
    {
      12, 12, 12, 12, 12, 13, 13, 14, 14, 15, 15, 16, 17, 17, 18, 19, 20, 21, 21, 22
    },
    {
      13, 13, 13, 13, 13, 14, 14, 14, 15, 16, 16, 17, 17, 18, 19, 20, 20, 21, 22, 23
    },
    {
      14, 14, 14, 14, 14, 14, 15, 15, 16, 16, 17, 17, 18, 19, 20, 20, 21, 22, 23, 23
    },
    {
      15, 15, 15, 15, 15, 15, 16, 16, 17, 17, 18, 18, 19, 20, 20, 21, 22, 22, 23, 24
    },
    {
      16, 16, 16, 16, 16, 16, 17, 17, 17, 18, 18, 19, 20, 20, 21, 22, 22, 23, 24, 25
    },
    {
      16, 17, 17, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 21, 22, 22, 23, 24, 24, 25
    },
    {
      17, 17, 18, 18, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25, 26
    },
    {
      18, 18, 19, 19, 19, 19, 19, 20, 20, 21, 21, 21, 22, 23, 23, 24, 24, 25, 26, 26
    },
    {
      19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27
    },

  },
  {
    {
      5, 5, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
    },
    {
      5, 5, 5, 6, 6, 7, 8, 9, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
    },
    {
      5, 5, 6, 6, 7, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
    },
    {
      6, 6, 6, 7, 7, 8, 8, 9, 10, 11, 12, 12, 13, 14, 15, 16, 17, 18, 19, 20
    },
    {
      6, 6, 7, 7, 8, 8, 9, 9, 10, 11, 12, 13, 14, 14, 15, 16, 17, 18, 19, 20
    },
    {
      7, 7, 7, 8, 8, 9, 9, 10, 11, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20
    },
    {
      8, 8, 8, 8, 9, 9, 10, 10, 11, 12, 13, 13, 14, 15, 16, 17, 18, 19, 20, 21
    },
    {
      9, 9, 9, 9, 9, 10, 10, 11, 12, 12, 13, 14, 15, 16, 16, 17, 18, 19, 20, 21
    },
    {
      9, 9, 10, 10, 10, 11, 11, 12, 12, 13, 14, 14, 15, 16, 17, 18, 19, 19, 20, 21
    },
    {
      10, 10, 10, 11, 11, 11, 12, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19, 20, 21, 22
    },
    {
      11, 11, 11, 12, 12, 12, 13, 13, 14, 14, 15, 16, 16, 17, 18, 19, 20, 20, 21, 22
    },
    {
      12, 12, 12, 12, 13, 13, 13, 14, 14, 15, 16, 16, 17, 18, 18, 19, 20, 21, 22, 23
    },
    {
      13, 13, 13, 13, 14, 14, 14, 15, 15, 16, 16, 17, 18, 18, 19, 20, 21, 21, 22, 23
    },
    {
      14, 14, 14, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 20, 20, 21, 22, 23, 24
    },
    {
      15, 15, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 19, 20, 20, 21, 22, 23, 23, 24
    },
    {
      16, 16, 16, 16, 16, 17, 17, 17, 18, 18, 19, 19, 20, 20, 21, 22, 22, 23, 24, 25
    },
    {
      17, 17, 17, 17, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 24, 25, 25
    },
    {
      18, 18, 18, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25, 25, 26
    },
    {
      19, 19, 19, 19, 19, 19, 20, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27
    },
    {
      20, 20, 20, 20, 20, 20, 21, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27
    },

  },
  {
    {
      6, 6, 6, 7, 7, 8, 8, 9, 10, 11, 12, 13, 13, 14, 15, 16, 17, 18, 19, 20
    },
    {
      6, 6, 6, 7, 7, 8, 9, 9, 10, 11, 12, 13, 13, 14, 15, 16, 17, 18, 19, 20
    },
    {
      6, 6, 7, 7, 7, 8, 9, 9, 10, 11, 12, 13, 14, 14, 15, 16, 17, 18, 19, 20
    },
    {
      7, 7, 7, 7, 8, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 16, 17, 18, 19, 20
    },
    {
      7, 7, 7, 8, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 16, 17, 18, 18, 19, 20
    },
    {
      8, 8, 8, 8, 9, 9, 10, 10, 11, 12, 13, 13, 14, 15, 16, 17, 18, 19, 20, 21
    },
    {
      8, 9, 9, 9, 9, 10, 10, 11, 12, 12, 13, 14, 15, 16, 16, 17, 18, 19, 20, 21
    },
    {
      9, 9, 9, 10, 10, 10, 11, 12, 12, 13, 14, 14, 15, 16, 17, 18, 18, 19, 20, 21
    },
    {
      10, 10, 10, 10, 11, 11, 12, 12, 13, 13, 14, 15, 16, 16, 17, 18, 19, 20, 21, 21
    },
    {
      11, 11, 11, 11, 12, 12, 12, 13, 13, 14, 15, 15, 16, 17, 18, 18, 19, 20, 21, 22
    },
    {
      12, 12, 12, 12, 12, 13, 13, 14, 14, 15, 15, 16, 17, 17, 18, 19, 20, 21, 21, 22
    },
    {
      13, 13, 13, 13, 13, 13, 14, 14, 15, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22, 23
    },
    {
      13, 13, 14, 14, 14, 14, 15, 15, 16, 16, 17, 17, 18, 19, 19, 20, 21, 22, 22, 23
    },
    {
      14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 19, 19, 20, 21, 21, 22, 23, 24
    },
    {
      15, 15, 15, 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 21, 21, 22, 23, 24, 24
    },
    {
      16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25
    },
    {
      17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25, 26
    },
    {
      18, 18, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26
    },
    {
      19, 19, 19, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 23, 24, 24, 25, 25, 26, 27
    },
    {
      20, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 23, 23, 24, 24, 25, 26, 26, 27, 28
    },

  },
  {
    {
      7, 7, 7, 8, 8, 9, 9, 10, 11, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20
    },
    {
      7, 7, 7, 8, 8, 9, 9, 10, 11, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20
    },
    {
      7, 7, 8, 8, 8, 9, 9, 10, 11, 12, 12, 13, 14, 15, 16, 17, 18, 18, 19, 20
    },
    {
      8, 8, 8, 8, 9, 9, 10, 10, 11, 12, 13, 13, 14, 15, 16, 17, 18, 19, 20, 20
    },
    {
      8, 8, 8, 9, 9, 9, 10, 11, 11, 12, 13, 14, 14, 15, 16, 17, 18, 19, 20, 21
    },
    {
      9, 9, 9, 9, 9, 10, 10, 11, 12, 12, 13, 14, 15, 16, 16, 17, 18, 19, 20, 21
    },
    {
      9, 9, 9, 10, 10, 10, 11, 12, 12, 13, 14, 14, 15, 16, 17, 18, 18, 19, 20, 21
    },
    {
      10, 10, 10, 10, 11, 11, 12, 12, 13, 13, 14, 15, 16, 16, 17, 18, 19, 20, 21, 21
    },
    {
      11, 11, 11, 11, 11, 12, 12, 13, 13, 14, 15, 15, 16, 17, 18, 18, 19, 20, 21, 22
    },
    {
      11, 11, 12, 12, 12, 12, 13, 13, 14, 15, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22
    },
    {
      12, 12, 12, 13, 13, 13, 14, 14, 15, 15, 16, 16, 17, 18, 19, 19, 20, 21, 22, 23
    },
    {
      13, 13, 13, 13, 14, 14, 14, 15, 15, 16, 16, 17, 18, 18, 19, 20, 21, 21, 22, 23
    },
    {
      14, 14, 14, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 20, 20, 21, 22, 23, 24
    },
    {
      15, 15, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 19, 20, 20, 21, 22, 23, 23, 24
    },
    {
      16, 16, 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 22, 22, 23, 24, 25
    },
    {
      17, 17, 17, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 21, 22, 22, 23, 24, 24, 25
    },
    {
      17, 17, 18, 18, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25, 26
    },
    {
      18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 21, 21, 22, 23, 23, 24, 24, 25, 26, 26
    },
    {
      19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 22, 22, 23, 23, 24, 24, 25, 26, 26, 27
    },
    {
      20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 28
    },

  },
  {
    {
      8, 8, 8, 9, 9, 9, 10, 11, 11, 12, 13, 14, 14, 15, 16, 17, 18, 19, 20, 21
    },
    {
      8, 8, 8, 9, 9, 9, 10, 11, 11, 12, 13, 14, 14, 15, 16, 17, 18, 19, 20, 21
    },
    {
      8, 8, 8, 9, 9, 10, 10, 11, 11, 12, 13, 14, 15, 15, 16, 17, 18, 19, 20, 21
    },
    {
      9, 9, 9, 9, 9, 10, 10, 11, 12, 12, 13, 14, 15, 16, 16, 17, 18, 19, 20, 21
    },
    {
      9, 9, 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 15, 16, 17, 17, 18, 19, 20, 21
    },
    {
      9, 9, 10, 10, 10, 11, 11, 12, 12, 13, 14, 14, 15, 16, 17, 18, 19, 19, 20, 21
    },
    {
      10, 10, 10, 10, 11, 11, 12, 12, 13, 13, 14, 15, 16, 16, 17, 18, 19, 20, 21, 21
    },
    {
      11, 11, 11, 11, 11, 12, 12, 13, 13, 14, 15, 15, 16, 17, 18, 18, 19, 20, 21, 22
    },
    {
      11, 11, 11, 12, 12, 12, 13, 13, 14, 14, 15, 16, 16, 17, 18, 19, 20, 20, 21, 22
    },
    {
      12, 12, 12, 12, 13, 13, 13, 14, 14, 15, 16, 16, 17, 18, 18, 19, 20, 21, 22, 22
    },
    {
      13, 13, 13, 13, 13, 14, 14, 15, 15, 16, 16, 17, 18, 18, 19, 20, 20, 21, 22, 23
    },
    {
      14, 14, 14, 14, 14, 14, 15, 15, 16, 16, 17, 17, 18, 19, 20, 20, 21, 22, 23, 23
    },
    {
      14, 14, 15, 15, 15, 15, 16, 16, 16, 17, 18, 18, 19, 19, 20, 21, 22, 22, 23, 24
    },
    {
      15, 15, 15, 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 21, 21, 22, 23, 24, 24
    },
    {
      16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25
    },
    {
      17, 17, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25, 25
    },
    {
      18, 18, 18, 18, 18, 19, 19, 19, 20, 20, 20, 21, 22, 22, 23, 23, 24, 25, 25, 26
    },
    {
      19, 19, 19, 19, 19, 19, 20, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27
    },
    {
      20, 20, 20, 20, 20, 20, 21, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27
    },
    {
      21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27, 28
    },

  },
  {
    {
      9, 9, 9, 9, 10, 10, 11, 11, 12, 13, 13, 14, 15, 16, 17, 17, 18, 19, 20, 21
    },
    {
      9, 9, 9, 10, 10, 10, 11, 11, 12, 13, 13, 14, 15, 16, 17, 18, 18, 19, 20, 21
    },
    {
      9, 9, 9, 10, 10, 10, 11, 12, 12, 13, 14, 14, 15, 16, 17, 18, 18, 19, 20, 21
    },
    {
      9, 10, 10, 10, 10, 11, 11, 12, 12, 13, 14, 15, 15, 16, 17, 18, 19, 19, 20, 21
    },
    {
      10, 10, 10, 10, 11, 11, 12, 12, 13, 13, 14, 15, 16, 16, 17, 18, 19, 20, 21, 21
    },
    {
      10, 10, 10, 11, 11, 11, 12, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19, 20, 21, 22
    },
    {
      11, 11, 11, 11, 12, 12, 12, 13, 13, 14, 15, 15, 16, 17, 18, 18, 19, 20, 21, 22
    },
    {
      11, 11, 12, 12, 12, 12, 13, 13, 14, 15, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22
    },
    {
      12, 12, 12, 12, 13, 13, 13, 14, 14, 15, 16, 16, 17, 18, 18, 19, 20, 21, 22, 22
    },
    {
      13, 13, 13, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 19, 20, 20, 21, 22, 23
    },
    {
      13, 13, 14, 14, 14, 14, 15, 15, 16, 16, 17, 17, 18, 19, 19, 20, 21, 22, 22, 23
    },
    {
      14, 14, 14, 15, 15, 15, 15, 16, 16, 17, 17, 18, 19, 19, 20, 21, 21, 22, 23, 24
    },
    {
      15, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 19, 19, 20, 21, 21, 22, 23, 23, 24
    },
    {
      16, 16, 16, 16, 16, 17, 17, 17, 18, 18, 19, 19, 20, 20, 21, 22, 22, 23, 24, 25
    },
    {
      17, 17, 17, 17, 17, 17, 18, 18, 18, 19, 19, 20, 21, 21, 22, 22, 23, 24, 25, 25
    },
    {
      17, 18, 18, 18, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25, 26
    },
    {
      18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25, 26, 26
    },
    {
      19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 26, 26, 27
    },
    {
      20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 28
    },
    {
      21, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 28, 28
    },

  },
  {
    {
      10, 10, 10, 10, 11, 11, 12, 12, 13, 13, 14, 15, 16, 16, 17, 18, 19, 20, 21, 21
    },
    {
      10, 10, 10, 10, 11, 11, 12, 12, 13, 13, 14, 15, 16, 16, 17, 18, 19, 20, 21, 21
    },
    {
      10, 10, 10, 11, 11, 11, 12, 12, 13, 14, 14, 15, 16, 17, 17, 18, 19, 20, 21, 22
    },
    {
      10, 10, 11, 11, 11, 12, 12, 13, 13, 14, 14, 15, 16, 17, 17, 18, 19, 20, 21, 22
    },
    {
      11, 11, 11, 11, 11, 12, 12, 13, 13, 14, 15, 15, 16, 17, 18, 18, 19, 20, 21, 22
    },
    {
      11, 11, 11, 12, 12, 12, 13, 13, 14, 14, 15, 16, 16, 17, 18, 19, 20, 20, 21, 22
    },
    {
      12, 12, 12, 12, 12, 13, 13, 14, 14, 15, 15, 16, 17, 17, 18, 19, 20, 21, 21, 22
    },
    {
      12, 12, 12, 13, 13, 13, 14, 14, 15, 15, 16, 16, 17, 18, 19, 19, 20, 21, 22, 23
    },
    {
      13, 13, 13, 13, 13, 14, 14, 15, 15, 16, 16, 17, 18, 18, 19, 20, 20, 21, 22, 23
    },
    {
      13, 13, 14, 14, 14, 14, 15, 15, 16, 16, 17, 17, 18, 19, 19, 20, 21, 22, 22, 23
    },
    {
      14, 14, 14, 14, 15, 15, 15, 16, 16, 17, 17, 18, 19, 19, 20, 21, 21, 22, 23, 24
    },
    {
      15, 15, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 19, 20, 20, 21, 22, 23, 23, 24
    },
    {
      16, 16, 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 22, 22, 23, 24, 25
    },
    {
      16, 16, 17, 17, 17, 17, 17, 18, 18, 19, 19, 20, 20, 21, 22, 22, 23, 24, 24, 25
    },
    {
      17, 17, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 22, 22, 23, 23, 24, 25, 26
    },
    {
      18, 18, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26
    },
    {
      19, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27
    },
    {
      20, 20, 20, 20, 20, 20, 21, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27
    },
    {
      21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27, 28
    },
    {
      21, 21, 22, 22, 22, 22, 22, 23, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 29
    },

  },
  {
    {
      11, 11, 11, 11, 12, 12, 13, 13, 14, 14, 15, 16, 16, 17, 18, 19, 19, 20, 21, 22
    },
    {
      11, 11, 11, 11, 12, 12, 13, 13, 14, 14, 15, 16, 16, 17, 18, 19, 19, 20, 21, 22
    },
    {
      11, 11, 11, 12, 12, 12, 13, 13, 14, 14, 15, 16, 16, 17, 18, 19, 20, 20, 21, 22
    },
    {
      11, 11, 12, 12, 12, 12, 13, 13, 14, 15, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22
    },
    {
      12, 12, 12, 12, 12, 13, 13, 14, 14, 15, 15, 16, 17, 17, 18, 19, 20, 21, 21, 22
    },
    {
      12, 12, 12, 12, 13, 13, 13, 14, 14, 15, 16, 16, 17, 18, 18, 19, 20, 21, 22, 23
    },
    {
      13, 13, 13, 13, 13, 13, 14, 14, 15, 15, 16, 17, 17, 18, 19, 20, 20, 21, 22, 23
    },
    {
      13, 13, 13, 13, 14, 14, 14, 15, 15, 16, 16, 17, 18, 18, 19, 20, 21, 21, 22, 23
    },
    {
      14, 14, 14, 14, 14, 14, 15, 15, 16, 16, 17, 17, 18, 19, 20, 20, 21, 22, 23, 23
    },
    {
      14, 14, 14, 15, 15, 15, 15, 16, 16, 17, 17, 18, 19, 19, 20, 21, 21, 22, 23, 24
    },
    {
      15, 15, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 19, 20, 20, 21, 22, 23, 23, 24
    },
    {
      16, 16, 16, 16, 16, 16, 17, 17, 17, 18, 18, 19, 20, 20, 21, 22, 22, 23, 24, 25
    },
    {
      16, 16, 16, 17, 17, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 23, 24, 24, 25
    },
    {
      17, 17, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25, 26
    },
    {
      18, 18, 18, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 22, 23, 23, 24, 25, 25, 26
    },
    {
      19, 19, 19, 19, 19, 19, 20, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27
    },
    {
      19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27
    },
    {
      20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 28
    },
    {
      21, 21, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 25, 25, 26, 26, 27, 28, 28
    },
    {
      22, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29
    },

  },
  {
    {
      12, 12, 12, 12, 13, 13, 13, 14, 14, 15, 16, 16, 17, 18, 18, 19, 20, 21, 22, 22
    },
    {
      12, 12, 12, 12, 13, 13, 13, 14, 14, 15, 16, 16, 17, 18, 18, 19, 20, 21, 22, 22
    },
    {
      12, 12, 12, 13, 13, 13, 14, 14, 15, 15, 16, 16, 17, 18, 19, 19, 20, 21, 22, 23
    },
    {
      12, 12, 13, 13, 13, 13, 14, 14, 15, 15, 16, 17, 17, 18, 19, 19, 20, 21, 22, 23
    },
    {
      13, 13, 13, 13, 13, 14, 14, 14, 15, 16, 16, 17, 17, 18, 19, 20, 20, 21, 22, 23
    },
    {
      13, 13, 13, 13, 14, 14, 14, 15, 15, 16, 16, 17, 18, 18, 19, 20, 21, 21, 22, 23
    },
    {
      13, 13, 14, 14, 14, 14, 15, 15, 16, 16, 17, 17, 18, 19, 19, 20, 21, 22, 22, 23
    },
    {
      14, 14, 14, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 20, 20, 21, 22, 23, 24
    },
    {
      14, 14, 15, 15, 15, 15, 16, 16, 16, 17, 18, 18, 19, 19, 20, 21, 22, 22, 23, 24
    },
    {
      15, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 19, 19, 20, 21, 21, 22, 23, 23, 24
    },
    {
      16, 16, 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 22, 22, 23, 24, 25
    },
    {
      16, 16, 16, 17, 17, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 23, 24, 24, 25
    },
    {
      17, 17, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25, 25
    },
    {
      18, 18, 18, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25, 25, 26
    },
    {
      18, 18, 19, 19, 19, 19, 19, 20, 20, 21, 21, 21, 22, 23, 23, 24, 24, 25, 26, 26
    },
    {
      19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 26, 26, 27
    },
    {
      20, 20, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 24, 24, 25, 26, 26, 27, 28
    },
    {
      21, 21, 21, 21, 21, 21, 22, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 28, 28
    },
    {
      22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 24, 24, 25, 25, 26, 26, 27, 28, 28, 29
    },
    {
      22, 22, 23, 23, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 27, 28, 28, 29, 29
    },

  },
  {
    {
      13, 13, 13, 13, 14, 14, 14, 15, 15, 16, 16, 17, 18, 18, 19, 20, 21, 21, 22, 23
    },
    {
      13, 13, 13, 13, 14, 14, 14, 15, 15, 16, 16, 17, 18, 18, 19, 20, 21, 21, 22, 23
    },
    {
      13, 13, 13, 13, 14, 14, 14, 15, 15, 16, 17, 17, 18, 18, 19, 20, 21, 21, 22, 23
    },
    {
      13, 13, 13, 14, 14, 14, 15, 15, 16, 16, 17, 17, 18, 19, 19, 20, 21, 22, 22, 23
    },
    {
      14, 14, 14, 14, 14, 14, 15, 15, 16, 16, 17, 17, 18, 19, 20, 20, 21, 22, 23, 23
    },
    {
      14, 14, 14, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 20, 20, 21, 22, 23, 24
    },
    {
      14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 19, 19, 20, 21, 21, 22, 23, 24
    },
    {
      15, 15, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 19, 20, 20, 21, 22, 23, 23, 24
    },
    {
      15, 15, 15, 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 21, 21, 22, 23, 24, 24
    },
    {
      16, 16, 16, 16, 16, 17, 17, 17, 18, 18, 19, 19, 20, 20, 21, 22, 22, 23, 24, 25
    },
    {
      16, 16, 17, 17, 17, 17, 17, 18, 18, 19, 19, 20, 20, 21, 22, 22, 23, 24, 24, 25
    },
    {
      17, 17, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25, 26
    },
    {
      18, 18, 18, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25, 25, 26
    },
    {
      18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 21, 21, 22, 23, 23, 24, 24, 25, 26, 26
    },
    {
      19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 26, 26, 27
    },
    {
      20, 20, 20, 20, 20, 20, 21, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27
    },
    {
      21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27, 28
    },
    {
      21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 29
    },
    {
      22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 28, 29, 29
    },
    {
      23, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 26, 26, 26, 27, 27, 28, 29, 29, 30
    },

  },
  {
    {
      14, 14, 14, 14, 15, 15, 15, 16, 16, 17, 17, 18, 18, 19, 20, 21, 21, 22, 23, 24
    },
    {
      14, 14, 14, 14, 15, 15, 15, 16, 16, 17, 17, 18, 18, 19, 20, 21, 21, 22, 23, 24
    },
    {
      14, 14, 14, 14, 15, 15, 15, 16, 16, 17, 17, 18, 19, 19, 20, 21, 21, 22, 23, 24
    },
    {
      14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 19, 19, 20, 21, 21, 22, 23, 24
    },
    {
      15, 15, 15, 15, 15, 15, 16, 16, 17, 17, 18, 18, 19, 20, 20, 21, 22, 22, 23, 24
    },
    {
      15, 15, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 19, 20, 20, 21, 22, 23, 23, 24
    },
    {
      15, 15, 15, 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 21, 21, 22, 23, 24, 24
    },
    {
      16, 16, 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 22, 22, 23, 24, 25
    },
    {
      16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25
    },
    {
      17, 17, 17, 17, 17, 17, 18, 18, 18, 19, 19, 20, 21, 21, 22, 22, 23, 24, 25, 25
    },
    {
      17, 17, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 22, 22, 23, 23, 24, 25, 26
    },
    {
      18, 18, 18, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 22, 23, 23, 24, 25, 25, 26
    },
    {
      18, 18, 19, 19, 19, 19, 19, 20, 20, 21, 21, 21, 22, 23, 23, 24, 24, 25, 26, 26
    },
    {
      19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 26, 26, 27
    },
    {
      20, 20, 20, 20, 20, 20, 21, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27
    },
    {
      21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27, 28
    },
    {
      21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 24, 24, 25, 25, 26, 27, 27, 28, 29
    },
    {
      22, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29
    },
    {
      23, 23, 23, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 27, 27, 28, 28, 29, 30
    },
    {
      24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 26, 26, 26, 27, 27, 28, 29, 29, 30, 30
    },

  },
  {
    {
      15, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 19, 19, 20, 21, 21, 22, 23, 23, 24
    },
    {
      15, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 21, 21, 22, 23, 23, 24
    },
    {
      15, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 21, 21, 22, 23, 24, 24
    },
    {
      15, 15, 15, 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 21, 21, 22, 23, 24, 24
    },
    {
      16, 16, 16, 16, 16, 16, 17, 17, 17, 18, 18, 19, 20, 20, 21, 22, 22, 23, 24, 25
    },
    {
      16, 16, 16, 16, 16, 17, 17, 17, 18, 18, 19, 19, 20, 20, 21, 22, 22, 23, 24, 25
    },
    {
      16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25
    },
    {
      17, 17, 17, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 21, 22, 22, 23, 24, 24, 25
    },
    {
      17, 17, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25, 25
    },
    {
      17, 18, 18, 18, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25, 26
    },
    {
      18, 18, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26
    },
    {
      19, 19, 19, 19, 19, 19, 20, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27
    },
    {
      19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 26, 26, 27
    },
    {
      20, 20, 20, 20, 20, 20, 21, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27
    },
    {
      21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27, 28
    },
    {
      21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 24, 24, 25, 25, 26, 27, 27, 28, 28
    },
    {
      22, 22, 22, 22, 22, 22, 23, 23, 23, 24, 24, 25, 25, 25, 26, 27, 27, 28, 28, 29
    },
    {
      23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 30
    },
    {
      23, 23, 24, 24, 24, 24, 24, 24, 25, 25, 25, 26, 26, 27, 27, 28, 28, 29, 30, 30
    },
    {
      24, 24, 24, 24, 25, 25, 25, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 30, 30, 31
    },

  },
  {
    {
      16, 16, 16, 16, 16, 17, 17, 17, 18, 18, 19, 19, 20, 21, 21, 22, 23, 23, 24, 25
    },
    {
      16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 19, 19, 20, 21, 21, 22, 23, 23, 24, 25
    },
    {
      16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25
    },
    {
      16, 16, 16, 17, 17, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 23, 24, 24, 25
    },
    {
      16, 17, 17, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 21, 22, 22, 23, 24, 24, 25
    },
    {
      17, 17, 17, 17, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 24, 25, 25
    },
    {
      17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25, 26
    },
    {
      17, 17, 18, 18, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25, 26
    },
    {
      18, 18, 18, 18, 18, 19, 19, 19, 20, 20, 20, 21, 22, 22, 23, 23, 24, 25, 25, 26
    },
    {
      18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25, 26, 26
    },
    {
      19, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27
    },
    {
      19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27
    },
    {
      20, 20, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 24, 24, 25, 26, 26, 27, 28
    },
    {
      21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27, 28
    },
    {
      21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 24, 24, 25, 25, 26, 27, 27, 28, 29
    },
    {
      22, 22, 22, 22, 22, 22, 23, 23, 23, 24, 24, 25, 25, 25, 26, 27, 27, 28, 28, 29
    },
    {
      23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 30
    },
    {
      23, 23, 23, 24, 24, 24, 24, 24, 25, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30
    },
    {
      24, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 27, 27, 28, 28, 29, 29, 30, 31
    },
    {
      25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31
    },

  },
  {
    {
      17, 17, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25, 25
    },
    {
      17, 17, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25, 26
    },
    {
      17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25, 26
    },
    {
      17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 20, 20, 21, 22, 22, 23, 24, 24, 25, 26
    },
    {
      17, 17, 18, 18, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25, 26
    },
    {
      18, 18, 18, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25, 25, 26
    },
    {
      18, 18, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26
    },
    {
      18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 21, 21, 22, 23, 23, 24, 24, 25, 26, 26
    },
    {
      19, 19, 19, 19, 19, 19, 20, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27
    },
    {
      19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 26, 26, 27
    },
    {
      20, 20, 20, 20, 20, 20, 21, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27
    },
    {
      20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 28
    },
    {
      21, 21, 21, 21, 21, 21, 22, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 28, 28
    },
    {
      21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 29
    },
    {
      22, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29
    },
    {
      23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 30
    },
    {
      23, 23, 23, 24, 24, 24, 24, 24, 25, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30
    },
    {
      24, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 27, 27, 28, 28, 29, 29, 30, 31
    },
    {
      25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 27, 27, 28, 28, 28, 29, 29, 30, 31, 31
    },
    {
      25, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32
    },

  },
  {
    {
      18, 18, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26
    },
    {
      18, 18, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26
    },
    {
      18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25, 26, 26
    },
    {
      18, 18, 18, 18, 19, 19, 19, 20, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25, 26, 26
    },
    {
      18, 18, 19, 19, 19, 19, 19, 20, 20, 21, 21, 21, 22, 23, 23, 24, 24, 25, 26, 26
    },
    {
      19, 19, 19, 19, 19, 19, 20, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27
    },
    {
      19, 19, 19, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 23, 24, 24, 25, 25, 26, 27
    },
    {
      19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 22, 22, 23, 23, 24, 24, 25, 26, 26, 27
    },
    {
      20, 20, 20, 20, 20, 20, 21, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27
    },
    {
      20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 28
    },
    {
      21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27, 28
    },
    {
      21, 21, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 25, 25, 26, 26, 27, 28, 28
    },
    {
      22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 24, 24, 25, 25, 26, 26, 27, 28, 28, 29
    },
    {
      22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 28, 29, 29
    },
    {
      23, 23, 23, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 27, 27, 28, 28, 29, 30
    },
    {
      23, 23, 24, 24, 24, 24, 24, 24, 25, 25, 25, 26, 26, 27, 27, 28, 28, 29, 30, 30
    },
    {
      24, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 27, 27, 28, 28, 29, 29, 30, 31
    },
    {
      25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 27, 27, 28, 28, 28, 29, 29, 30, 31, 31
    },
    {
      25, 25, 26, 26, 26, 26, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32
    },
    {
      26, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32
    },

  },
  {
    {
      19, 19, 19, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 23, 24, 24, 25, 25, 26, 27
    },
    {
      19, 19, 19, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 23, 24, 24, 25, 26, 26, 27
    },
    {
      19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 26, 26, 27
    },
    {
      19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 26, 26, 27
    },
    {
      19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27
    },
    {
      20, 20, 20, 20, 20, 20, 21, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27
    },
    {
      20, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 23, 23, 24, 24, 25, 26, 26, 27, 28
    },
    {
      20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 28
    },
    {
      21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27, 28
    },
    {
      21, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 28, 28
    },
    {
      21, 21, 22, 22, 22, 22, 22, 23, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 29
    },
    {
      22, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29
    },
    {
      22, 22, 23, 23, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 27, 28, 28, 29, 29
    },
    {
      23, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 26, 26, 26, 27, 27, 28, 29, 29, 30
    },
    {
      24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 26, 26, 26, 27, 27, 28, 29, 29, 30, 30
    },
    {
      24, 24, 24, 24, 25, 25, 25, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 30, 30, 31
    },
    {
      25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31
    },
    {
      25, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32
    },
    {
      26, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32
    },
    {
      27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 29, 29, 29, 30, 30, 31, 31, 32, 32, 33
    }
  }
};

int bfs_cur_marker;

void bfs_reset_marks()
{
  bfs_cur_marker = 1;
  for (int curr_room = 0; curr_room <= top_of_world; curr_room++)
    world[curr_room].bfs_mark = 0;
}
void bfs_clear_marks()
{
  bfs_cur_marker++;
  if (bfs_cur_marker == INT_MAX)
    bfs_reset_marks();
}


static struct mm_ds *dead_bfs_pool = NULL;

struct bfs_queue_struct
{
  int      room;
  int      dir;
  int      step_no;
  struct bfs_queue_struct *next;
};

static struct bfs_queue_struct *queue_head = 0, *queue_tail = 0;

static void bfs_enqueue(int room, int dir, int step)
{
  struct bfs_queue_struct *curr;

  curr = (struct bfs_queue_struct *) mm_get(dead_bfs_pool);
  /*
   * CREATE(curr, struct bfs_queue_struct, 1); 
   */
  curr->room = room;
  curr->dir = (ubyte) dir;
  curr->step_no = step;
  curr->next = 0;

  if (queue_tail)
  {
    queue_tail->next = curr;
    queue_tail = curr;
  }
  else
    queue_head = queue_tail = curr;
}

static void bfs_dequeue(void)
{
  struct bfs_queue_struct *curr;

  curr = queue_head;

  if (!(queue_head = queue_head->next))
    queue_tail = 0;
  mm_release(dead_bfs_pool, curr);
/*
 * FREE((char *)curr); 
 */
}

static void bfs_clear_queue(void)
{
  while (queue_head)
    bfs_dequeue();
}

// some very specialized versions of FFS to hopefully help with speed... less
// conditionals for the "generic" ffs should reduce its CPU overhead.
static byte FFS_ship(int src, int target, int *ttl_steps)
{
  int      curr_dir;
  int      curr_room;
  ulong    i = 0U;

  if (!dead_bfs_pool)
    dead_bfs_pool = mm_create("HUNT", sizeof(struct bfs_queue_struct),
                              offsetof(struct bfs_queue_struct, next), 1);

  if (src < 0 || src > top_of_world || target < 0 || target > top_of_world)
  {
    logit(LOG_DEBUG, "Illegal value passed to find_first_step (graph.c)");
    return BFS_ERROR;
  }
  if (src == target)
  {
    return BFS_ALREADY_THERE;
  }
  
  bfs_clear_marks();
  BFSMARK(src);

  for (curr_dir = 0; curr_dir < NUM_EXITS; curr_dir++)
    if (VALID_SHIP_EDGE(src, curr_dir))
    {
      BFSMARK(TOROOM(src, curr_dir));
      bfs_enqueue(TOROOM(src, curr_dir), curr_dir, 1);
    }
  while (queue_head)
  {
    if (i++ > BFS_MAX_ROOMS)
    {
      bfs_clear_queue();
      logit(LOG_DEBUG,"overcame bfs_max_rooms");
      return BFS_ERROR;
    }
    
    if (queue_head->room == target)
    {
      curr_dir = queue_head->dir;
      *ttl_steps = queue_head->step_no;
      bfs_clear_queue();
      return curr_dir;
    }
    else
    {
      for (curr_dir = 0; curr_dir < NUM_EXITS; curr_dir++)
      {
        if (VALID_SHIP_EDGE(queue_head->room, curr_dir)) 
        {
          BFSMARK(TOROOM(queue_head->room, curr_dir));
          bfs_enqueue(TOROOM(queue_head->room, curr_dir), queue_head->dir,
                      queue_head->step_no + 1);
        }
      }
      bfs_dequeue();
    }
  }
  return BFS_NO_PATH;
}


static byte FFS_wagon(int src, int target, int *ttl_steps)
{
  int      curr_dir;
  int      curr_room;
  ulong    i = 0U;

  if (!dead_bfs_pool)
    dead_bfs_pool = mm_create("HUNT", sizeof(struct bfs_queue_struct),
                              offsetof(struct bfs_queue_struct, next), 1);

  if (src < 0 || src > top_of_world || target < 0 || target > top_of_world)
  {
    logit(LOG_DEBUG, "Illegal value passed to find_first_step (graph.c)");
    return BFS_ERROR;
  }
  if (src == target)
    return BFS_ALREADY_THERE;
  
  bfs_clear_marks();
  BFSMARK(src);

  for (curr_dir = 0; curr_dir < NUM_EXITS; curr_dir++)
    if (VALID_WAGON_EDGE(src, curr_dir))
    {
      BFSMARK(TOROOM(src, curr_dir));
      bfs_enqueue(TOROOM(src, curr_dir), curr_dir, 1);
    }
  while (queue_head)
  {
    if (i++ > BFS_MAX_ROOMS)
    {
      bfs_clear_queue();
      return BFS_ERROR;
    }
    if (queue_head->room == target)
    {
      curr_dir = queue_head->dir;
      *ttl_steps = queue_head->step_no;
      bfs_clear_queue();
      return curr_dir;
    }
    else
    {
      for (curr_dir = 0; curr_dir < NUM_EXITS; curr_dir++)
      {
        BFSMARK(TOROOM(queue_head->room, curr_dir));
        bfs_enqueue(TOROOM(queue_head->room, curr_dir), queue_head->dir,
                    queue_head->step_no + 1);
      }
      bfs_dequeue();
    }
  }
  return BFS_NO_PATH;
}

extern const int rev_dir[];

static byte FFS_flying(int src, int target, int *ttl_steps)
{
  int      curr_dir;
  int      curr_room;
  ulong    i = 0U;
  
  if (!dead_bfs_pool)
    dead_bfs_pool = mm_create("HUNT", sizeof(struct bfs_queue_struct),
                              offsetof(struct bfs_queue_struct, next), 1);
  
  if (src < 0 || src > top_of_world || target < 0 || target > top_of_world)
  {
    logit(LOG_DEBUG, "Illegal value passed to find_first_step (graph.c)");
    return BFS_ERROR;
  }
  if (src == target)
  {
    return BFS_ALREADY_THERE;
  }
  
  bfs_clear_marks();
  BFSMARK(src);
  
  for (curr_dir = 0; curr_dir < NUM_EXITS; curr_dir++)
    if (VALID_FLYING_EDGE(src, curr_dir))
    {
      BFSMARK(TOROOM(src, curr_dir));
      bfs_enqueue(TOROOM(src, curr_dir), curr_dir, 1);
    }
      while (queue_head)
      {
        if (i++ > BFS_MAX_ROOMS_MAP)
        {
          bfs_clear_queue();
          debug("FFS_flying(): overcame bfs_max_rooms");
          logit(LOG_DEBUG,"overcame bfs_max_rooms");
          return BFS_ERROR;
        }
        
        if (queue_head->room == target)
        {
          curr_dir = queue_head->dir;
          *ttl_steps = queue_head->step_no;
          bfs_clear_queue();
          return curr_dir;
        }
        else
        {
          for (curr_dir = 0; curr_dir < NUM_EXITS; curr_dir++)
          {
            if (VALID_FLYING_EDGE(queue_head->room, curr_dir)) 
            {
              BFSMARK(TOROOM(queue_head->room, curr_dir));
              bfs_enqueue(TOROOM(queue_head->room, curr_dir), queue_head->dir,
                          queue_head->step_no + 1);
            }
          }
          bfs_dequeue();
        }
      }
      return BFS_NO_PATH;
}

/*
 * find_first_step: given a source room and a target room, find the first
 * step on the shortest path from the source to the target.
 * 
 * can_fly should be TRUE if a path can go over WATER_NOSWIM and NOGROUND
 * rooms.
 * 
 * ttl_steps will result in being the total number of step required to get 
 * to the destination. (assuming its possible)
 * 
 * Intended usage: in mobile_activity, give a mob a dir to go if they're
 * tracking another mob or a PC.  Or, a 'track' skill for PCs. 
 */
/*
 * NOTE: this uses REAL room numbers!! 
 */
byte find_first_step(int src, int target, long hunt_flags,
                  int is_ship, int wagon_type, int *ttl_steps)
{
  int      curr_dir;
  int      curr_room;
  ulong    i = 0U;
  P_char tar;

  if(is_ship)
  {
    return FFS_ship(src, target, ttl_steps);
  }
  
  if(wagon_type == WAGON_TYPE_WAGON)
  {
    return FFS_wagon(src, target, ttl_steps);
  }
  
  if (wagon_type == WAGON_TYPE_FLYING)
  {
    return FFS_flying(src, target, ttl_steps);
  }

  bool rr_targ = IS_SET(hunt_flags, BFS_ROADRANGER);

  if (!dead_bfs_pool)
    dead_bfs_pool = mm_create("HUNT", sizeof(struct bfs_queue_struct),
                              offsetof(struct bfs_queue_struct, next), 1);

  if (src < 0 || src > top_of_world || target < 0 || target > top_of_world)
  {
    logit(LOG_DEBUG, "Illegal value passed to find_first_step (graph.c): src %d", src);
    return BFS_ERROR;
  }

  if ((rr_targ ? IS_ROADRANGER_TARGET(src) : (src == target)))
  {
    return BFS_ALREADY_THERE;
  }
  
  // setup some flags.  code is cleaner with booleans than with checking
  // bit flags...
  bool can_fly = IS_SET(hunt_flags, BFS_CAN_FLY);
  bool can_dispel = IS_SET(hunt_flags, BFS_CAN_DISPEL);
  bool can_break = IS_SET(hunt_flags, BFS_BREAK_WALLS);
  bool stay_zone = IS_SET(hunt_flags, BFS_STAY_ZONE);
  
  // clear marks first 
  bfs_clear_marks();
  BFSMARK(src);

  // first, enqueue the first steps, saving which direction we're going. 
  for (curr_dir = 0; curr_dir < NUM_EXITS; curr_dir++)
  {
    if(VALID_EDGE(src, curr_dir) && 
      (can_fly || !NEEDS_FLY(src, curr_dir)) &&
      (!stay_zone || SAME_ZONE(src, curr_dir)) &&
      (can_dispel || !IS_WALLED(src, curr_dir) || 
      (can_break && IS_BREAKABLE(src, curr_dir))))
    {
      BFSMARK(TOROOM(src, curr_dir));
      bfs_enqueue(TOROOM(src, curr_dir), curr_dir, 1);
    }
  }
  // now, do the classic BFS. 
  while (queue_head)
  {
    if (i++ > BFS_MAX_ROOMS)
    {
      // ack!  we searched too many rooms... Who the heck is in the room?
      for(tar = world[queue_head->room].people; tar; tar = tar->next_in_room)
      {
        if(!tar)
        {
          logit(LOG_DEBUG,"graph.c error on queue_head search.");
          break;
        }
        if(IS_PC(tar))
        {
          //logit(LOG_DEBUG,"PC (%s) with next too many rooms searched.", GET_NAME(tar));
          continue;
        }
        if(IS_NPC(tar))
        {
          //logit(LOG_DEBUG,"NPC (%d) with next too many rooms searched.", mob_index[GET_RNUM(tar)].virtual_number);
          continue;
        }
      }
      
      // debug
     
      /*
      logit(LOG_DEBUG,"too many rooms searched from room (%d) target (%d) is_ship (%d) wagon_type(%d)",
        ROOM_VNUM(src),
        ROOM_VNUM(target),
        is_ship,
        wagon_type);
     */
      bfs_clear_queue();

      return BFS_ERROR;
    }
    
    if ((rr_targ ? IS_ROADRANGER_TARGET(queue_head->room) : (queue_head->room == target)))
    {
      curr_dir = queue_head->dir;
      *ttl_steps = queue_head->step_no;
      bfs_clear_queue();
      return curr_dir;
    }
    else
    {
      for (curr_dir = 0; curr_dir < NUM_EXITS; curr_dir++)
      {
        if (VALID_EDGE(queue_head->room, curr_dir) &&
            (can_fly || !NEEDS_FLY(queue_head->room, curr_dir)) &&
            (!stay_zone || SAME_ZONE(queue_head->room, curr_dir)) &&
            (can_dispel || 
             !IS_WALLED(queue_head->room, curr_dir) || 
             (can_break && IS_BREAKABLE(queue_head->room, curr_dir)))) 
        {
          BFSMARK(TOROOM(queue_head->room, curr_dir));
          bfs_enqueue(TOROOM(queue_head->room, curr_dir), queue_head->dir,
                      queue_head->step_no + 1);
        }
      }
      bfs_dequeue();
    }
  }
  return BFS_NO_PATH;
}


/* given a source real room, and target real room, how far apart are
   they?  Function checks through all room sector types!  and all
   room/exit flags.  This gives a true distance based on the shortest
   possible route.  To limit the search, "max_steps" is the maximum
   number of steps to check.  Function returns the number of steps
   away the target room is, or a negative number if there is no path.
   */
int how_close(int src, int target, int max_steps)
{
  int      curr_dir;
  int      curr_room;
  ulong    i = 0U;

  if (max_steps < 0)
    max_steps = 0;

  if (!dead_bfs_pool)
    dead_bfs_pool = mm_create("HUNT",
                              sizeof(struct bfs_queue_struct),
                              offsetof(struct bfs_queue_struct, next), 1);

  if (src < 0 || src > top_of_world || target < 0 || target > top_of_world)
  {
    logit(LOG_DEBUG, "Illegal value passed to how_close() (graph.c)");
    return BFS_ERROR;
  }
  if (src == target)
    return 0;

  /* clear marks first  */
  bfs_clear_marks();
  BFSMARK(src);

  /* first, enqueue the first steps, saving which direction we're going. */
  for (curr_dir = 0; curr_dir < NUM_EXITS; curr_dir++)
    if (VALID_DIST_EDGE(src, curr_dir))
    {
      BFSMARK(TOROOM(src, curr_dir));
      bfs_enqueue(TOROOM(src, curr_dir), curr_dir, 1);
    }
  /* now, do the classic BFS. */
  while (queue_head)
  {
    if (i++ > BFS_MAX_ROOMS)
    {
      /* ack!  we searched too many rooms.. just give up */
      bfs_clear_queue();
      return BFS_ERROR;
    }
    if (queue_head->room == target)
    {
      int      distance = queue_head->step_no;

      curr_dir = queue_head->dir;
      bfs_clear_queue();
      return distance;
    }
    else if (queue_head->step_no > max_steps)
    {
      bfs_clear_queue();
      return BFS_NO_PATH;
    }
    else
    {
      for (curr_dir = 0; curr_dir < NUM_EXITS; curr_dir++)
        if (VALID_DIST_EDGE(queue_head->room, curr_dir))
        {
          BFSMARK(TOROOM(queue_head->room, curr_dir));
          bfs_enqueue(TOROOM(queue_head->room, curr_dir), queue_head->dir,
                      queue_head->step_no + 1);
        }
      bfs_dequeue();
    }
  }

  return BFS_NO_PATH;
}



/*
 * find the path from 'from' to 'to' (real room nums.. not virtual). If
 * max_steps is non-zero, only include max_steps steps in the right
 * direction....  (DO NOT ABUSE THIS!...IF THE 'to' IS VERY FAR FROM
 * 'from' THIS WILL LAG THE SHIT OUTTA THE MUD!).  Note that max_steps is
 * limited to MAX_STRING_LENGTH (which is far indeed). It might be prudent
 * to check that 'from' is in the same zone as 'to' before calling this
 * function.  However, I didn't want to hardcode this type of restriction,
 * as justice code WILL need to track across zones.
 * 
 * Will return a ubyte array of directions (which the caller is responsible 
 * for deallocating).  The last direction in the array will be '-1'. If the 
 * return value is NULL, a path couldn't be found, or some other error
 * occured.  
 * 
 * As well, max_steps will be changed to the actual number of steps in the
 * array (not including the -1).  (So if a target is 1 room away, max_steps 
 * will be 1, and the returned array will have 2 elements)
 * 
 */

ubyte   *find_the_path(int from, int to, int *max_steps, long hunt_flags)
{
  byte     path[MAX_STRING_LENGTH];
  ubyte   *ret_path;
  unsigned i;
  byte     next_step;
  int      room_no;
  int      dummy;

  if (*max_steps <= 0)
    *max_steps = MAX_STRING_LENGTH - 1;

  room_no = from;

  for (i = 0; i < *max_steps; i++)
  {
    next_step = find_first_step(room_no, to, hunt_flags, 0, 0, &dummy);
    if(next_step == BFS_ALREADY_THERE)
    {
      break;
    }
    
    if (next_step < 0)
    {
      *max_steps = 0;
      return NULL;
    }
    
    path[i] = next_step;
    room_no = TOROOM(room_no, (int) next_step);
  }

  *max_steps = i;
  path[i] = -1;

  CREATE(ret_path, ubyte, (i + 1), MEM_TAG_BUFFER);
  bcopy(path, ret_path, (int) i + 1);
  return ret_path;
}

byte line_of_sight_dir(int src, int target)
{
  int      curr_dir;
  int      curr_room;
  ulong    i = 0U;

  if (!dead_bfs_pool)
    dead_bfs_pool = mm_create("HUNT", sizeof(struct bfs_queue_struct),
                              offsetof(struct bfs_queue_struct, next), 1);

  if (src < 0 || src > top_of_world || target < 0 || target > top_of_world)
  {
    logit(LOG_DEBUG, "Illegal value passed to find_first_step (graph.c)");
    return BFS_ERROR;
  }
  if (src == target)
  {
    return BFS_ALREADY_THERE;
  }
  /*
   * clear marks first 
   */
  bfs_clear_marks();
  BFSMARK(src);

  /*
   * first, enqueue the first steps, saving which direction we're going. 
   */
  for (curr_dir = 0; curr_dir < NUM_EXITS; curr_dir++)
  {
    if (VALID_EDGE(src, curr_dir))
    {
      BFSMARK(TOROOM(src, curr_dir));
      bfs_enqueue(TOROOM(src, curr_dir), curr_dir, 1);
    }
  }
  /*
   * now, do the classic BFS. 
   */
  while (queue_head)
  {
    if (i++ > BFS_MAX_ROOMS)
    {
      /*
       * ack!  we searched too many rooms.. just give up 
       */
      bfs_clear_queue();
      return BFS_ERROR;
    }
    if (queue_head->room == target)
    {
      curr_dir = queue_head->dir;
      bfs_clear_queue();
      return curr_dir;
    }
    else
    {
      for (curr_dir = 0; curr_dir < NUM_EXITS; curr_dir++)
      {
        if (VALID_EDGE(queue_head->room, curr_dir))
        {
          BFSMARK(TOROOM(queue_head->room, curr_dir));
          bfs_enqueue(TOROOM(queue_head->room, curr_dir), queue_head->dir,
                      queue_head->step_no + 1);
        }
      }
      bfs_dequeue();
    }
  }
  return BFS_NO_PATH;
}

struct BFSNode {
  BFSNode(int _room_num, BFSNode* _prev, int _to_here_dir) :
    room_num(_room_num),
    prev(_prev),
    next(NULL),
    to_here_dir(_to_here_dir)
  {
    
  }

  void reset() {
    room_num = -1;
    prev = NULL;
    next = NULL;
    to_here_dir = -1;
  }

  int room_num;
  BFSNode* prev;
  BFSNode* next;
  int to_here_dir;
};


/* this function is CPU HUNGRY and does not guarantee the optimal path. Use dijkstra() instead - it's also cpu hungry but at least it will find the optimal path */
bool find_ship_path(int from_room, int to_room, vector<int>& path) {
  path.clear();

  queue<BFSNode*> q; // bread-first search queue

  list<BFSNode*> nodes; // stores pointers for cleanup later
    
  int rooms_searched = 0;	

  // reset all room "seen" flags
  bfs_clear_marks();

  // push the first room
  BFSMARK(from_room);
  BFSNode* cur_node = new BFSNode(from_room, NULL, -1);
  nodes.push_back(cur_node);
  q.push(cur_node);

  while( !q.empty() ) {
    cur_node = q.front();
    q.pop();
    
    if( cur_node->room_num == to_room ) {
      // made it to the destination! now we start at the end and go back
      // to the beginning, pushing the directions onto the path vector
      while( cur_node->prev ) {
        path.push_back(cur_node->to_here_dir);
        cur_node = cur_node->prev;
      }
      
      // reverse the directions in the path vector
      int temp;
      int i, j;
      for( i = 0, j = path.size()-1; i < j; i++, j-- ) {
        temp = path[i];
        path[i]	= path[j];
        path[j] = temp;
      }

      // clean up the BFS nodes
      for( list<BFSNode*>::iterator it = nodes.begin(); it != nodes.end(); it++ ) {
        if( *it ) {
          delete *it;
          *it = NULL;
        }
      }
            
      return true;
    }

    if( rooms_searched++ > BFS_MAX_ROOMS ) {
      fprintf(stderr, "(find_ship_path failed: too many rooms searched)");
      return false;
    }

    // push all valid neighbors onto the queue
    for( int dir = 0; dir < NUM_EXITS; dir++ ) {
      if( VALID_SHIP_EDGE(cur_node->room_num, dir) ) {
        BFSMARK(TOROOM(cur_node->room_num, dir));
        cur_node = new BFSNode(TOROOM(cur_node->room_num, dir), cur_node, dir);
        nodes.push_back(cur_node);
        q.push(cur_node);
      }
    }
        
  }

  // didn't find a path

  // clean up the BFS nodes
  for( list<BFSNode*>::iterator it = nodes.begin(); it != nodes.end(); it++ ) {
    if( *it ) {
      delete *it;
      *it = NULL;
    }
  }

  return false;
}

#include <limits.h>
#include <queue>

/*

classes and function for finding the shortest path using Dijkstra's Algorithm.

This is a "greedy" algorithm, but due to the low relative connectivity of the mud, works well for finding
the shortest path. Should only rarely be called (for instance: mud bootup), not on a frequent basis.

a valid_edge_func needs to be passed into dijkstra; valid_ship_edge has already been provided.

*/

struct SearchNode {
  SearchNode() : room_id(0), dist(INT_MAX) {}
  SearchNode(int _room_id, int _dist) : room_id(_room_id), dist(_dist) {}
  bool operator<(const SearchNode& rhs) const {
    return dist > rhs.dist;
  }
  SearchNode& operator=(const SearchNode& rhs) {
    room_id = rhs.room_id;
    dist = rhs.dist;
    return *this;
  }
  int room_id;
  int dist;
};

struct PathNode {
  PathNode() : room_id(0), to_dir(0) {}
  PathNode(int _room_id, int _to_dir) : room_id(_room_id), to_dir(_to_dir) {}
  int room_id;
  int to_dir;
};

bool valid_ship_edge(int from_room, int dir) {
  return VALID_SHIP_EDGE(from_room, dir);
}

bool dijkstra(int from_room, int to_room, valid_edge_func *valid_edge, vector<int>& path) {	
  vector<int> dist(top_of_world, INT_MAX);
  vector<PathNode> prev(top_of_world, PathNode());

  priority_queue<SearchNode> pq;

  SearchNode node;

  dist[from_room] = 0;

  bfs_clear_marks();

  pq.push(SearchNode(from_room, 0));

  while( !pq.empty() ) {
    node = pq.top();
    pq.pop();
        
    if( node.room_id == to_room ) {
      // found the path
      break;
    }
    
    for( int dir = 0; dir < NUM_EXITS; dir++ ) {
      if( !valid_edge(node.room_id, dir) ) continue;
      
      int tmp = TOROOM(node.room_id, dir);
      if( dist[tmp] > dist[node.room_id] + 1 ) {
        // "relax"!
        dist[tmp] = dist[node.room_id] + 1;
        prev[tmp] = PathNode(node.room_id, dir);
      }
      
      pq.push( SearchNode(tmp, dist[tmp]) );
      BFSMARK(tmp);
    }
    
  }

  if( dist[to_room] < INT_MAX ) {
    // path exists; follow shortest path backwards
    path.clear();
    PathNode pn = prev[to_room];
    for( int i = 0; i < dist[to_room]; i++ ) {
      //path.push_back(pn.to_dir);
      path.insert(path.begin(), pn.to_dir);
      pn = prev[pn.room_id];
    }

    return true;
    
  } else {
    // no path exists
    return false;
  }
    
}

mm_ds *dead_rmfr_pool = NULL;

struct RMFR_QUEUE_ITEM
{
  int      room;
  int      dir;
  int      x;
  int      y;
  int      z;
  RMFR_QUEUE_ITEM *next;
};

RMFR_QUEUE_ITEM *rmfr_queue_head = NULL, *rmfr_queue_tail = NULL;

const int x_delta[NUM_EXITS] = { 0, 1, 0, -1, 0, 0, -1, -1, 1, 1 };
const int y_delta[NUM_EXITS] = { 1, 0, -1, 0, 0, 0, 1, -1, 1, -1 };
const int z_delta[NUM_EXITS] = { 0, 0, 0, 0, 1, -1, 0, 0, 0, 0 };

void rmfr_enqueue(int room, int dir, RMFR_Q_TYPE qt)
{
  RMFR_QUEUE_ITEM *curr;
  int x, y, z;

  if(qt != RMFR_Q_FIRST && rmfr_queue_head)
  {
    x = rmfr_queue_head->x + x_delta[dir];
    y = rmfr_queue_head->y + y_delta[dir];
    z = rmfr_queue_head->z + z_delta[dir];
  }
  else
  {
    x = x_delta[dir];
    y = y_delta[dir];
    z = z_delta[dir];
  }

  curr = (RMFR_QUEUE_ITEM *) mm_get(dead_rmfr_pool);

  curr->room = TOROOM(room, dir);
  BFSMARK(curr->room);
  //debug("rmfr_enqueue - queueing up room %d", curr->room);
  curr->x = x;
  curr->y = y;
  curr->z = z;
  curr->next = 0;

  if (rmfr_queue_tail)
  {
    rmfr_queue_tail->next = curr;
    rmfr_queue_tail = curr;
  }
  else
    rmfr_queue_head = rmfr_queue_tail = curr;
}

void rmfr_dequeue(void)
{
  RMFR_QUEUE_ITEM *curr;

  curr = rmfr_queue_head;

  if (!(rmfr_queue_head = rmfr_queue_head->next))
    rmfr_queue_tail = 0;
  mm_release(dead_rmfr_pool, curr);
}

static void rmfr_clear_queue(void)
{
  while (rmfr_queue_head)
    rmfr_dequeue();
}

bool rmfr_valid_exit(int room, int dir, int radius, RMFR_FLAGS flags, RMFR_Q_TYPE qt)
{

  if(!world[room].dir_option[dir])
    return false;

  if(TOROOM(room, dir) == NOWHERE)
    return false;
  
  if(IS_MARKED(TOROOM(room, dir)))
    return false;

  switch(dir)
  {
    case NORTH:
      if(!(flags & RMFR_RADIATE_NORTH))
        return false;
      break;
    case SOUTH:
      if(!(flags & RMFR_RADIATE_SOUTH))
        return false;
      break;
    case EAST:
      if(!(flags & RMFR_RADIATE_EAST))
        return false;
      break;
    case WEST:
      if(!(flags & RMFR_RADIATE_WEST))
        return false;
      break;
    case UP:
      if(!(flags & RMFR_RADIATE_UP))
        return false;
      break;
    case DOWN:
      if(!(flags & RMFR_RADIATE_DOWN))
        return false;
      break;
    case NORTHEAST:
      if(!(flags & RMFR_RADIATE_NE))
        return false;
      break;
    case SOUTHEAST:
      if(!(flags & RMFR_RADIATE_SE))
        return false;
      break;
    case SOUTHWEST:
      if(!(flags & RMFR_RADIATE_SW))
        return false;
      break;
    case NORTHWEST:
      if(!(flags & RMFR_RADIATE_NW))
        return false;
      break;
    default:
      return false;
  }
  
  if(!(flags & RMFR_CROSS_ZONE_BARRIER) && !SAME_ZONE(room, dir))
    return false;

  if((flags & RMFR_INDOORS_ONLY) && IS_OUTSIDE(TOROOM(room, dir)))
    return false;

  if((flags & RMFR_OUTDOORS_ONLY) && IS_INSIDE(TOROOM(room, dir)))
    return false;

  if(!(flags & RMFR_PASS_DOOR) && IS_CLOSED(room, dir))
    return false;

  if(!(flags & RMFR_PASS_BLOCKED) && IS_BLOCKED(room, dir))
    return false;

  if(!(flags & RMFR_PASS_WALL) && IS_WALLED(room, dir))
    return false;

  // all relevant flags checked, check distance
  int x, y, z;

  if(qt != RMFR_Q_FIRST && rmfr_queue_head)
  {
    x = rmfr_queue_head->x + x_delta[dir];
    y = rmfr_queue_head->y + y_delta[dir];
    z = rmfr_queue_head->z + z_delta[dir];
  }
  else
  {
    x = x_delta[dir];
    y = y_delta[dir];
    z = z_delta[dir];
  }
  
  //debug("rmfr_valid_exit - dir: %d, x: %i, y: %i, z: %i, radius: %d, distance: %d", dir, x, y, z, radius, distance_array[abs(x)][abs(y)][abs(z)]);
  
  // max it can radiate is 20 rooms in any given direction
  if(x >= MAX_AXIS_INDEX || y >= MAX_AXIS_INDEX || z >= MAX_AXIS_INDEX)
    return false;

  x = abs(x);
  y = abs(y);
  z = abs(z);

  if(distance_array[x][y][z] > radius)
    return false;

  return true;
}


void radiate_message_from_room(int room, char* message, int radius, RMFR_FLAGS flags, int pcbase)
{
  int      curr_dir;
  int      curr_room;
  int      src = room;
  ulong    i = 0U;
  int      chance;
  P_char   tar;

  //debug("radiate_message_from_room called with params - room %d, radius %d, flags %08x, pcbase %d, message: %s", room, radius, flags, pcbase, message);

  // sanity checking
  if(!message || radius < 1)
  {
    logit(LOG_EXIT, "radiate_message_from_room: bad params");
    raise(SIGSEGV);
  }

  // more sanity, but easier to have this happen, so just log problem and bail
  if (src < 0 || src > top_of_world)
  {
    logit(LOG_DEBUG, "Illegal room value passed to radiate_message_from_room");
    return;
  }

  /* 
  * Slight change here - we will be called from lots of strange places now, so lets just 
  * trim the distance to the max and live with the new value. A trick here too - if gods 
  * see the wizlog message often enough, someone will move his lazy ass to fix the problem.
  */
  if (radius > RMFR_MAX_RADIUS)
  {
    wizlog(MINLVLIMMORTAL, "radiate_message_from_room - called in %d with too high distance", src);
    radius = RMFR_MAX_RADIUS;
  }

  // make sure we have a pool of queue items
  if (!dead_rmfr_pool)
  {
    dead_rmfr_pool = mm_create("RMFR", sizeof(RMFR_QUEUE_ITEM), offsetof(RMFR_QUEUE_ITEM, next), 1);
    if(!dead_rmfr_pool)
    {
      logit(LOG_EXIT, "Cannot create dead_rmfr_pool");
      raise(SIGSEGV);
    }
    //debug("created RMFR pool");
  }
  
  // default perception check if it wasn't specified
  if(flags & RMFR_REQUIRE_PERCEPTION_CHECK && !pcbase)
    pcbase = RMFR_DEFAULT_PERCEPTION_CHECK;

  // RMFR_RADIATE_ALL_DIRS is a bitwise-or of all direction bits,
  // so if this bitwise-and results in 0, then no directions were specified
  // default to all directions
  if(!(flags & RMFR_RADIATE_ALL_DIRS))
    flags = (RMFR_FLAGS)(flags | RMFR_RADIATE_ALL_DIRS);

  // clear marks first 
  bfs_clear_marks();

  // mark our start room
  BFSMARK(src);

  // enqueue the first steps
  for (curr_dir = 0; curr_dir < NUM_EXITS; curr_dir++)
  {
    if (rmfr_valid_exit(src, curr_dir, radius, flags, RMFR_Q_FIRST))
    {
      rmfr_enqueue(src, curr_dir, RMFR_Q_FIRST);
    }
  }

  // now, do the classic BFS (w/o actually looking for an end ^_^)
  while (rmfr_queue_head)
  {
    if (i++ > BFS_MAX_ROOMS)
    {
      // unless there is some funky room linking, this shouldn't happen
      rmfr_clear_queue();
      logit(LOG_DEBUG, "radiate_message_from_room - too many rooms searched");
      return;
    }
    
    // if requiring perception check...
    if(flags & RMFR_REQUIRE_PERCEPTION_CHECK)
    {
      for(tar = world[rmfr_queue_head->room].people; tar; tar = tar->next_in_room)
      {
        if(IS_NPC(tar))
          continue;
        // ...check all people in the room
        // chance = BOUNDED(wis/10, pcbase + wis/5 - distance*2, 99)
        chance = pcbase + (GET_C_WIS(tar) / 5);
        if(flags & RMFR_INCREASE_PC_DIFF_OVER_DISTANCE)
          chance -= distance_array[abs(rmfr_queue_head->x)][abs(rmfr_queue_head->y)][abs(rmfr_queue_head->z)] * 2;
        chance = BOUNDED(GET_C_WIS(tar) / 10, chance, 99);
        if(number(0, 100) <= chance)
        {
          send_to_char(message, tar);
        }
      }
    }
    else
    {
      // otherwise just send the message to the room
      send_to_room(message, rmfr_queue_head->room);
    }

    // enqueue all valid exits from here too
    for (curr_dir = 0; curr_dir < NUM_EXITS; curr_dir++)
    {
      if (rmfr_valid_exit(rmfr_queue_head->room, curr_dir, radius, flags, RMFR_Q_OTHER))
      {
        rmfr_enqueue(rmfr_queue_head->room, curr_dir, RMFR_Q_OTHER);
      }
    }

    // next room
    rmfr_dequeue();
  }
}
