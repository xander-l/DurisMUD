/*
 **************************************************************************
 *  File: sound.c                                             Part of Duris 
 *  Usage: sound fonction for MSP
 *  Copyright 1994 - 2008 - Duris Systems Ltd.
 **************************************************************************
 */

#include <ctype.h>
#include <stdio.h>
#include <string.h>

#include "comm.h"
#include "db.h"
#include "events.h"
#include "interp.h"
#include "prototypes.h"
#include "structs.h"
#include "utils.h"
#include "sound.h"

extern P_desc descriptor_list;
extern P_room world;

void play_sound(const char *mess, P_char ch, int where, int type)
{
  if (type < TO_ROOM || type > TO_WORLD)
    return;

  switch (type)
  {
  case TO_CHAR:
    if (ch)
      sound_to_char(mess, ch);
    break;
  case TO_ROOM:
    if (where > 0)
      sound_to_room(mess, where);
    break;
  case TO_ZONE:
    if (where > 0)
      sound_to_zone(mess, where);
    break;
  case TO_WORLD:
    sound_to_all(mess);
    break;
  }
}

void sound_to_char(const char *messg, P_char ch)
{
  return;
  if (ch && ch->desc && messg && ch->desc->term_type == TERM_MSP)
  {
    delete_doubledollar(messg);
    write_to_q(messg, &ch->desc->output, 2);
  }
}

void sound_to_all(const char *messg)
{
  P_desc   i;

  return;
  if (messg)
    for (i = descriptor_list; i; i = i->next)
      if (!i->connected && i->term_type == TERM_MSP)
        write_to_q(messg, &i->output, 2);
}

void sound_to_room(const char *messg, int room)
{
  P_char   i;

  return;
  if (messg)
    for (i = world[room].people; i; i = i->next_in_room)
      if (i->desc && i->desc->term_type == TERM_MSP)
        if (IS_TRUSTED(i) ||
            !IS_SET(world[i->in_room].room_flags, ROOM_SILENT) ||
            i->specials.z_cord == 0)
          write_to_q(messg, &i->desc->output, 2);
}

void sound_to_zone(const char *messg, int zone)
{
  P_desc   i;

  return;
  if (messg)
    for (i = descriptor_list; i; i = i->next)
      if (!i->connected && i->term_type == TERM_MSP)
        if (world[i->character->in_room].zone == zone)
          write_to_q(messg, &i->output, 2);
}

/* started by Tavril, perhaps someday this will be needed - of course, it
   doesn't work yet, so it's commented out */

#if 0
char    *remove_soundcode_from_str(char *strn)
{
  int      i, len;

  if (!strn)
    return NULL;
  if (!strn[0])
    return strn;

  len = strlen(strn);

  for (i = 0; i < len; i++)
  {
    if (toupper(strn[i]) == 'S')
      return strn;
  }

  return strn;
}
#endif

/* Sounds generated by zones */
/* add any vnum from the zone to the noiszone switch. The bumper should 
   be at 2-3x the number of case in the switch. */


static int noisezone = 1;

void zone_noises(void)
{
  int      tempzone, noiseact = 1;

  switch (noisezone)
  {
  case 3:
    tempzone = real_room(6074);
    noiseact = number(1, 10);   /* your zone is sounds 1-10 */
    break;
  default:
    tempzone = 0;
    break;
  }

  if (noisezone == 5)           /* this is 2-3x cases above */
    noisezone = 0;
  noisezone++;

  if ((tempzone != 0) && (tempzone != NOWHERE))
    tempzone = world[tempzone].zone;

  if (tempzone != 0)
  {
    switch (noiseact)
    {                           /* Add a sound to each case here */
    case 1:
      play_sound(SOUND_TOWN_JANITOR, NULL, tempzone, TO_ZONE);
      break;
    case 2:
      play_sound(SOUND_CROWD_CLAPPING, NULL, tempzone, TO_ZONE);
      break;
    case 3:
      play_sound(SOUND_DOG1, NULL, tempzone, TO_ZONE);
      break;
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    default:
      break;
    }
  }

  // no... just... no, let it die
  //AddEvent(EVENT_SPECIAL, PULSE_MOBILE + number(10, 20), TRUE, zone_noises, 0);
}
