/*************************************************************
* account.c
*************************************************************/

#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <time.h>
#include <ctype.h>
#include <crypt.h>

#include "account.h"
#include "comm.h"
#include "mm.h"
#include "db.h"
#include "graph.h"
#include "interp.h"
#include "objmisc.h"
#include "prototypes.h"
#include "structs.h"
#include "spells.h"
#include "utils.h"
#include <math.h>

// External Stuff
extern P_index obj_index;
extern P_obj object_list;
extern P_room world;
extern const int top_of_world;
extern struct time_info_data time_info;
extern const char *dirs[];
extern P_desc descriptor_list;
extern P_char character_list;
extern struct mm_ds *dead_mob_pool;
extern struct mm_ds *dead_pconly_pool;

struct acct_entry *account_list = NULL;

#define ACCT_SERIAL                1
#define ACCOUNT_EMAIL_DB                "Accounts/email.db"

bool     account_exists(const char *, char *);
void     check_rested_bonus(P_desc);

// Bcrypt helper functions for account passwords
char* bcrypt_hash_password(const char *password)
{
  // Generate bcrypt hash with cost factor 12
  // Salt is automatically generated by crypt()
  char *salt = crypt_gensalt("$2b$", 12, NULL, 0);
  if (!salt)
    return NULL;

  char *hash = crypt(password, salt);
  return hash ? strdup(hash) : NULL;
}

int bcrypt_verify_password(const char *password, const char *hash)
{
  // Verify password against bcrypt hash
  char *result = crypt(password, hash);
  if (!result)
    return 0;

  return strcmp(result, hash) == 0 ? 1 : 0;
}

int is_bcrypt_hash(const char *hash)
{
  // Bcrypt hashes start with $2a$, $2b$, or $2y$
  return (hash && strlen(hash) > 4 &&
          hash[0] == '$' && hash[1] == '2' &&
          (hash[2] == 'a' || hash[2] == 'b' || hash[2] == 'y') &&
          hash[3] == '$');
}

// Email validation function with strict RFC compliance
// Returns 1 if valid, 0 if invalid
int is_valid_email(const char *email)
{
  const char *p;
  int at_count = 0, dot_after_at = 0;
  int local_len = 0, domain_len = 0;
  char prev_char = '\0';

  if (!email || !*email)
    return 0;

  // Find the @ symbol and validate local part
  for (p = email; *p && *p != '@'; p++)
  {
    local_len++;

    // Check for valid characters in local part
    if (!isalnum(*p) && *p != '.' && *p != '-' && *p != '_' && *p != '+')
      return 0;

    // Can't start with a dot
    if (local_len == 1 && *p == '.')
      return 0;

    // Can't have consecutive dots
    if (*p == '.' && prev_char == '.')
      return 0;

    prev_char = *p;
  }

  // Local part must exist and can't end with dot
  if (local_len == 0 || local_len > 64 || prev_char == '.')
    return 0;

  // Must have exactly one @
  if (*p != '@')
    return 0;

  p++; // Skip the @
  at_count = 0;
  prev_char = '\0';

  // Validate domain part
  for (; *p; p++)
  {
    domain_len++;

    // Check for valid characters in domain
    if (!isalnum(*p) && *p != '.' && *p != '-')
      return 0;

    // Can't start with dot or hyphen
    if (domain_len == 1 && (*p == '.' || *p == '-'))
      return 0;

    // Can't have consecutive dots
    if (*p == '.' && prev_char == '.')
      return 0;

    // Track if we have a dot after @
    if (*p == '.')
      dot_after_at = 1;

    prev_char = *p;
  }

  // Domain must exist, have at least one dot, and can't end with dot or hyphen
  if (domain_len == 0 || domain_len > 253 || !dot_after_at ||
      prev_char == '.' || prev_char == '-')
    return 0;

  // Check for second @ symbol (invalid)
  for (p = email; *p; p++)
  {
    if (*p == '@')
    {
      at_count++;
      if (at_count > 1)
        return 0;
    }
  }

  return 1;
}


void select_accountname(P_desc d, char *arg)
{
  char     tmp_name[MAX_INPUT_LENGTH];
  char     Gbuf1[MAX_STRING_LENGTH];
  P_desc   t_d = NULL;
  char     acct_in_game = 0;

  for (; isspace(*arg); arg++) ;
  if (!*arg)
  {
    close_socket(d);
    return;
  }

  if (_parse_name(arg, tmp_name))
  {
    SEND_TO_Q("Illegal account name, please try another.\r\n", d);
    SEND_TO_Q("Account Name: ", d);
    return;
  }

  *tmp_name = toupper(*tmp_name);

  if (!d->account)
  {
    d->account = allocate_account();
    if (!d->account)
    {
      SEND_TO_Q
        ("ERROR:  Could not allocate a new account, notify an immortal!\r\n",
         d);
      statuslog(56,
                "&+RALERT&n:  Could not allocate memory for a new account!");
      STATE(d) = CON_FLUSH;
      return;
    }
  }

  d->account->acct_name = str_dup(tmp_name);

  if (account_exists("Accounts", tmp_name))
  {
    if (read_account(d->account) == -1)
    {
      SEND_TO_Q
        ("There is an error with your account, please notify an immortal!\r\n",
         d);
      statuslog(56, "&+RALERT&n:  Account corrupt: %s", tmp_name);
      d->account = free_account(d->account);
      STATE(d) = CON_FLUSH;
      return;
    }

    SEND_TO_Q("Please enter your password: ", d);
    echo_off(d);
    STATE(d) = CON_GET_ACCT_PASSWD;
    return;
  }

  verify_account_name(d, NULL);
  STATE(d) = CON_VERIFY_NEW_ACCT_NAME;
  return;
}

void get_account_password(P_desc d, char *arg)
{
  // skip whitespace
  for (; isspace(*arg); arg++) ;

  if (!arg)
  {
    d->account = free_account(d->account);
    close_socket(d);
    return;
  }

  if (*arg == -1)
  {
    if (arg[1] != '0' && arg[2] != '0')
    {
      if (arg[3] == '0')
      {                         /* Password on next read  */
        return;
      }
      else
      {                         /* Password available */
        arg = arg + 3;
      }
    }
    else
      d->account = free_account(d->account);
    close_socket(d);
  }

  if (!arg)
  {
    d->account = free_account(d->account);
    close_socket(d);
    return;
  }

  // Check password - support both bcrypt (new) and MD5 (legacy)
  int password_valid = 0;
  int needs_upgrade = 0;

  if (is_bcrypt_hash(d->account->acct_password))
  {
    // Modern bcrypt hash
    password_valid = bcrypt_verify_password(arg, d->account->acct_password);
  }
  else
  {
    // Legacy MD5 hash - verify with CRYPT2
    password_valid = (strcmp(CRYPT2(arg, d->account->acct_password), d->account->acct_password) == 0);
    if (password_valid)
      needs_upgrade = 1;  // Upgrade to bcrypt after successful login
  }

  if (!password_valid)
  {
    SEND_TO_Q("Invalid Password ... disconnecting\r\n", d);
    d->account = free_account(d->account);
    STATE(d) = CON_FLUSH;
    return;
  }

  // Auto-upgrade MD5 passwords to bcrypt
  if (needs_upgrade)
  {
    char *new_hash = bcrypt_hash_password(arg);
    if (new_hash)
    {
      FREE(d->account->acct_password);
      d->account->acct_password = str_dup(new_hash);
      free(new_hash);
      write_account(d->account);  // Save upgraded password
    }
  }

  // Check for duplicate account login - kick old connection if found
  P_desc k;
  for (k = descriptor_list; k; k = k->next)
  {
    if ((k != d) && k->account && k->account->acct_name &&
        !strcasecmp(k->account->acct_name, d->account->acct_name))
    {
      // Same account already logged in - disconnect the old connection
      SEND_TO_Q("\r\n\r\nYour account has been logged in from another location.\r\n", k);
      SEND_TO_Q("Disconnecting...\r\n\r\n", k);
      close_socket(k);
      SEND_TO_Q("Overriding old connection...\r\n", d);
      break;  // Only one duplicate should exist
    }
  }

  echo_on(d);
#ifdef REQUIRE_EMAIL_VERIFICATION
  if (is_account_confirmed(d))
  {
    // Display MOTD before showing account menu
    SEND_TO_Q(motd.c_str(), d);
    SEND_TO_Q("\r\n*** PRESS RETURN: ", d);
    update_account_iplist(d);
    STATE(d) = CON_ACCT_RMOTD;
    return;
  }
  else
  {
    confirm_account(d, NULL);
    STATE(d) = CON_CONFIRM_ACCT;
    return;
  }
#else
  // Email verification disabled - skip confirmation and go directly to MOTD
  SEND_TO_Q(motd.c_str(), d);
  SEND_TO_Q("\r\n*** PRESS RETURN: ", d);
  update_account_iplist(d);
  STATE(d) = CON_ACCT_RMOTD;
  return;
#endif
}

void display_account_menu(P_desc d, char *arg)
{
  if (!arg)
  {
    char buf[256];

    SEND_TO_Q("\r\n", d);
    SEND_TO_Q("&+y/===========================================\\&n\r\n", d);
    snprintf(buf, 256, "&+y|&n         &+W%s&n's &+CACCOUNT MENU&n          &+y|&n\r\n", d->account->acct_name);
    SEND_TO_Q(buf, d);
    SEND_TO_Q("&+y\\===========================================/&n\r\n", d);
    SEND_TO_Q("\r\n", d);

    SEND_TO_Q("&+G1) Select a character to play&n\r\n", d);
    SEND_TO_Q("&+G2) Create a new character&n\r\n", d);
    SEND_TO_Q("&+R3) Delete a character&n\r\n", d);
    SEND_TO_Q("\r\n", d);
    SEND_TO_Q("&+C4) Display account information&n\r\n", d);
    SEND_TO_Q("&+Y5) Change registered email address&n\r\n", d);
    SEND_TO_Q("&+Y6) Change account password&n\r\n", d);
    SEND_TO_Q("&+R7) Delete this account&n\r\n", d);
    SEND_TO_Q("&+C8) Check rested bonus&n\r\n", d);
    SEND_TO_Q("\r\n", d);
    SEND_TO_Q("&+L0) Disconnect from this account&n\r\n", d);
    SEND_TO_Q("&+y------------------------------------------&n\r\n", d);
    SEND_TO_Q("Please select an option: ", d);
    return;
  }
  switch (atoi(arg))
  {
  case 0:
    STATE(d) = CON_FLUSH;
    SEND_TO_Q("\r\n\r\nThank you for playing!\r\n", d);
    write_account(d->account);
    break;

  case 1:
    STATE(d) = CON_ACCT_SELECT_CHAR;
    account_select_char(d, NULL);
    break;

  case 2:
    SEND_TO_Q("Enter your new name:  ", d);
    STATE(d) = CON_ACCT_NEW_CHAR_NAME;
    break;

  case 3:
    STATE(d) = CON_ACCT_DELETE_CHAR;
    account_delete_char(d, NULL);
    break;

  case 4:
    STATE(d) = CON_ACCT_DISPLAY_INFO;
    account_display_info(d, NULL);
    break;

  case 5:
    STATE(d) = CON_ACCT_CHANGE_EMAIL;
    get_new_account_email(d, NULL);
    break;

  case 6:
    STATE(d) = CON_ACCT_CHANGE_PASSWD;
    get_new_account_password(d, NULL);
    break;

  case 7:
    STATE(d) = CON_ACCT_DELETE_ACCT;
    delete_account(d, NULL);
    break;

  case 8:
    check_rested_bonus(d);
    break;

  default:
    SEND_TO_Q("Invalid Selection, please try again.\r\n", d);
    display_account_menu(d, NULL);
    break;
  }
}

void confirm_account(P_desc d, char *arg)
{
  char debug_buf[512];

  if (!arg)
  {
    SEND_TO_Q("Please enter the confirmation code shown above: ",
              d);
    return;
  }

  // Trim any whitespace from the input
  while (*arg && isspace(*arg)) arg++;

  // Fix doubled $ characters (MUD color code escaping)
  // When user types $, it comes through as $$
  char fixed_input[512];
  char *src = arg;
  char *dst = fixed_input;
  while (*src && (dst - fixed_input) < 511) {
    *dst++ = *src++;
    if (*(src-1) == '$' && *src == '$') {
      src++;  // Skip the doubled $
    }
  }
  *dst = '\0';

  // Debug output
  snprintf(debug_buf, 512, "\r\n&+YDEBUG: Entered='%s' (len=%d)&n\r\n&+YDEBUG: Fixed='%s' (len=%d)&n\r\n&+YDEBUG: Stored='%s' (len=%d)&n\r\n",
           arg, (int)strlen(arg),
           fixed_input, (int)strlen(fixed_input),
           d->account->acct_confirmation ? d->account->acct_confirmation : "NULL",
           d->account->acct_confirmation ? (int)strlen(d->account->acct_confirmation) : 0);
  SEND_TO_Q(debug_buf, d);

  if (str_cmp(fixed_input, d->account->acct_confirmation))
  {
    SEND_TO_Q("\r\n&+RInvalid confirmation code.&n\r\n", d);
    SEND_TO_Q("Please try again or reconnect to get a new code.\r\n", d);
    SEND_TO_Q("Please enter the confirmation code: ", d);
    return;  // Allow retry instead of disconnecting
  }
  else
  {
    SEND_TO_Q("\r\n&+GThank you for confirming your account!&n\r\n\r\n", d);
    d->account->acct_confirmed = 1;
    if (-1 == write_account(d->account))
    {
      SEND_TO_Q
        ("Oh no, I couldn't write your account information to disk, notify a god!\r\n",
         d);
      d->account = free_account(d->account);
      STATE(d) = CON_FLUSH;
    }
    STATE(d) = CON_DISPLAY_ACCT_MENU;
    display_account_menu(d, NULL);
    write_account(d->account);
  }

}

void verify_account_name(P_desc d, char *arg)
{
  char     buf[1024];

  if (!arg)
  {
    *d->account->acct_name = toupper(*d->account->acct_name);
    snprintf(buf, 1024, "You chose the name %s, is this correct? (Y/N)  ",
            d->account->acct_name);
    SEND_TO_Q(buf, d);
    return;
  }

  if ((arg[0] == 'y') || (arg[0] == 'Y'))
  {
    SEND_TO_Q("Confirmed...\r\n", d);
    STATE(d) = CON_GET_NEW_ACCT_EMAIL;
    get_new_account_email(d, NULL);
    return;
  }
  else if ((arg[0] == 'n') || (arg[0] == 'N'))
  {
    SEND_TO_Q("Ok, what then?\r\n", d);
    d->account = free_account(d->account);
    STATE(d) = CON_GET_ACCT_NAME;
    return;
  }
  else
  {
    SEND_TO_Q("Invalid choice...\r\n", d);
    verify_account_name(d, NULL);
  }
}



void get_new_account_email(P_desc d, char *arg)
{
  if (!arg)
  {
    SEND_TO_Q("\r\nPlease enter your email address:  ", d);
    return;
  }
  for (; isspace(*arg); arg++) ;

  // Validate email format
  if (!is_valid_email(arg))
  {
    SEND_TO_Q("\r\n&+RInvalid email format.&n Please enter a valid email address.\r\n", d);
    SEND_TO_Q("Email address:  ", d);
    return;
  }

  d->account->acct_email = str_dup(arg);
  STATE(d) = CON_VERIFY_NEW_ACCT_EMAIL;
  verify_new_account_email(d, NULL);
  return;
}

void verify_new_account_email(P_desc d, char *arg)
{
  char     buf[1024];

  if (!arg)
  {
    snprintf(buf, 1024, "\r\nYou entered %s, is this correct?  (Y/N)",
            d->account->acct_email);
    SEND_TO_Q(buf, d);
    return;
  }
  if ((arg[0] == 'y') || (arg[0] == 'Y'))
  {
    SEND_TO_Q("Confirmed...\r\n", d);
    if (d->account->acct_confirmed == 0)
    {
      STATE(d) = CON_GET_NEW_ACCT_PASSWD;
      get_new_account_password(d, NULL);
    }
    else
    {
      STATE(d) = CON_DISPLAY_ACCT_MENU;
      display_account_menu(d, NULL);
      write_account(d->account);
    }
    return;
  }
  else if ((arg[0] == 'n') || (arg[0] == 'N'))
  {
    SEND_TO_Q("Ok, what then?\r\n", d);
    FREE(d->account->acct_email);
    d->account->acct_email = NULL;
    STATE(d) = CON_GET_NEW_ACCT_EMAIL;
    return;
  }
  else
  {
    SEND_TO_Q("Invalid choice...\r\n", d);
    verify_new_account_email(d, NULL);
  }

}

void get_new_account_password(P_desc d, char *arg)
{
  char     password[256];

  if (!arg)
  {
    echo_on(d);
    SEND_TO_Q("Please enter your password:  ", d);
    echo_off(d);
    return;
  }
  echo_on(d);

  for (; isspace(*arg); arg++) ;

  if (!arg)
  {
    SEND_TO_Q("Invalid Password, try again.\r\n", d);
    get_new_account_password(d, NULL);
    return;
  }

  if (!valid_password(d, arg))
  {
    get_new_account_password(d, NULL);
    return;
  }

  // Use bcrypt for account passwords
  char *hash = bcrypt_hash_password(arg);
  if (!hash)
  {
    SEND_TO_Q("Error hashing password, please try again.\r\n", d);
    get_new_account_password(d, NULL);
    return;
  }

  d->account->acct_password = str_dup(hash);
  free(hash);
  STATE(d) = CON_VERIFY_NEW_ACCT_PASSWD;
  verify_new_account_password(d, NULL);
  return;
}

void verify_new_account_password(P_desc d, char *arg)
{
  if (!arg)
  {
    echo_on(d);
    SEND_TO_Q("Please verify your password:  ", d);
    echo_off(d);
    return;
  }
  echo_on(d);

  // Use bcrypt to verify the password
  if (!bcrypt_verify_password(arg, d->account->acct_password))
  {
    SEND_TO_Q("Passwords do not match!\r\n", d);
    get_new_account_password(d, NULL);
    FREE(d->account->acct_password);
    d->account->acct_password = NULL;
    STATE(d) = CON_GET_NEW_ACCT_PASSWD;
    return;
  }

  if (d->account->acct_confirmed == 0)
  {
    STATE(d) = CON_VERIFY_NEW_ACCT_INFO;
    verify_new_account_information(d, NULL);
  }
  else
  {
    STATE(d) = CON_DISPLAY_ACCT_MENU;
    display_account_menu(d, NULL);
    write_account(d->account);
  }
  return;
}

void verify_new_account_information(P_desc d, char *arg)
{
  if (!arg)
  {
    display_account_information(d);
    SEND_TO_Q("\r\nIs this information correct?  (Y/N) ", d);
    return;
  }
  if ((arg[0] == 'y') || (arg[0] == 'Y'))
  {
#ifdef REQUIRE_EMAIL_VERIFICATION
    SEND_TO_Q
      ("You will receive a confimation code in your email.\r\nYou must confirm your account before using it.\r\n\r\n",
       d);
    generate_account_confirmation_code(d, NULL);
    write_account(d->account);
    // Don't disconnect - go straight to confirmation prompt
    STATE(d) = CON_CONFIRM_ACCT;
    SEND_TO_Q("Please enter the confirmation code shown above: ", d);
#else
    // Email verification disabled - skip confirmation and go directly to menu
    SEND_TO_Q("&+GAccount created successfully!&n\r\n\r\n", d);
    generate_account_confirmation_code(d, NULL);  // Still generates code (for display) but auto-confirms
    write_account(d->account);
    SEND_TO_Q(motd.c_str(), d);
    SEND_TO_Q("\r\n*** PRESS RETURN: ", d);
    update_account_iplist(d);
    STATE(d) = CON_ACCT_RMOTD;
#endif
    return;
  }
  else if ((arg[0] == 'n') || (arg[0] == 'N'))
  {
    SEND_TO_Q("Ok, starting over!\r\n", d);
    d->account = free_account(d->account);
    STATE(d) = CON_GET_ACCT_NAME;
    SEND_TO_Q("Please enter your account name: ", d);
    return;
  }
  else
  {
    SEND_TO_Q("Invalid choice...\r\n", d);
    verify_new_account_information(d, NULL);
  }
}

void update_account_iplist(P_desc d)
{
  P_acct   acct = d->account;
  struct acct_ip *ip = NULL;

  ip = find_ip_entry(acct, d);

  if (!ip)
  {
    add_ip_entry(acct, d);
    return;
  }
  else
  {
    ip->count++;
    write_account(acct);
    return;
  }
}

struct acct_ip *find_ip_entry(P_acct acct, P_desc d)
{
  struct acct_ip *a = acct->acct_unique_ips;

  if (!a)
    return NULL;

  while (a)
  {
    if (!strcmp(a->hostname, d->host))
      return a;
    else
      a = a->next;
  }

  return NULL;
}

void add_ip_entry(P_acct acct, P_desc d)
{
  char     host[512];
  struct acct_ip *a = NULL;
  struct acct_ip *b = NULL;

  snprintf(host, 512, "%s", d->host);

  CREATE(a, acct_ip, 1, MEM_TAG_OTHER);

  a->hostname = str_dup(host);
  a->count = 1;
  a->ip_address = str_dup(host);
  acct->num_ips++;
  a->next = acct->acct_unique_ips;
  acct->acct_unique_ips = a;
  return;
}

void account_select_char(P_desc d, char *arg)
{
  struct acct_chars *c = NULL;
  struct acct_chars *sorted_chars[MAX_CHARS_PER_ACCOUNT];
  struct acct_chars *temp;
  P_char   ch = NULL;
  int selection = -1;
  int count = 0, i, j;

  if (!arg)
  {
    display_character_list(d);
    return;
  }

  // Check if input is numeric
  if (isdigit(arg[0]))
  {
    selection = atoi(arg);

    // Option 0 = back to account menu
    if (selection == 0)
    {
      STATE(d) = CON_DISPLAY_ACCT_MENU;
      display_account_menu(d, NULL);
      return;
    }

    // Build sorted character list (same as display_character_list)
    temp = d->account->acct_character_list;
    while (temp && count < MAX_CHARS_PER_ACCOUNT)
    {
      sorted_chars[count++] = temp;
      temp = temp->next;
    }

    // Sort by last login time (most recent first)
    for (i = 0; i < count - 1; i++)
    {
      for (j = 0; j < count - i - 1; j++)
      {
        if (sorted_chars[j]->last < sorted_chars[j+1]->last)
        {
          struct acct_chars *swap = sorted_chars[j];
          sorted_chars[j] = sorted_chars[j+1];
          sorted_chars[j+1] = swap;
        }
      }
    }

    // Validate selection
    if (selection < 1 || selection > count)
    {
      SEND_TO_Q("&+RInvalid selection.&n\r\n\r\n", d);
      display_character_list(d);
      return;
    }

    // Get the selected character (1-based index)
    c = sorted_chars[selection - 1];
  }
  else
  {
    // Text-based selection (for backward compatibility)
    c = find_char_in_list(d->account->acct_character_list, arg);
  }

  if (!c)
  {
    SEND_TO_Q("Sorry, I couldn't find that character!\r\n", d);
    display_character_list(d);
    return;
  }

  if (!can_connect(c, d))
  {
    char buf[512];
    int current_time = time(NULL);
    int time_remaining = 0;
    int minutes_remaining = 0;

    // Calculate time remaining for racewar timer
    if (c->racewar == ACCT_GOOD && current_time < (d->account->acct_evil + 3600))
    {
      time_remaining = (d->account->acct_evil + 3600) - current_time;
      minutes_remaining = (time_remaining + 59) / 60; // Round up
      snprintf(buf, 512,
        "\r\n&+RSorry, you cannot play this Good-aligned character yet!&n\r\n"
        "You must wait &+Y%d&n more minute%s before playing a Good character.\r\n"
        "(You recently played an Evil character)\r\n\r\n",
        minutes_remaining, minutes_remaining == 1 ? "" : "s");
      SEND_TO_Q(buf, d);
    }
    else if (c->racewar == ACCT_EVIL && current_time < (d->account->acct_good + 3600))
    {
      time_remaining = (d->account->acct_good + 3600) - current_time;
      minutes_remaining = (time_remaining + 59) / 60; // Round up
      snprintf(buf, 512,
        "\r\n&+RSorry, you cannot play this Evil-aligned character yet!&n\r\n"
        "You must wait &+Y%d&n more minute%s before playing an Evil character.\r\n"
        "(You recently played a Good character)\r\n\r\n",
        minutes_remaining, minutes_remaining == 1 ? "" : "s");
      SEND_TO_Q(buf, d);
    }
    else if (c->blocked)
    {
      SEND_TO_Q("\r\n&+RThis character has been blocked and cannot be played.&n\r\n\r\n", d);
    }
    else
    {
      SEND_TO_Q("Sorry, you can't play that character right now!\r\n", d);
    }

    display_character_list(d);
    return;
  }

  if (is_char_in_game(c, d))
  {
    return;
  }

  // Store the selected character name for confirmation
  if (d->selected_char_name)
    str_free(d->selected_char_name);
  d->selected_char_name = str_dup(c->charname);

  // Capitalize character name for display
  char name_cap[32];
  strncpy(name_cap, c->charname, 31);
  name_cap[31] = '\0';
  if (name_cap[0])
    name_cap[0] = toupper(name_cap[0]);

  // Send confirmation prompt
  char confirm_buf[256];
  snprintf(confirm_buf, 256, "\r\nPlay as &+W%s&n? (Y/N) ", name_cap);
  SEND_TO_Q(confirm_buf, d);

  // Change state to confirmation
  STATE(d) = CON_ACCT_CONFIRM_CHAR;

  return;

}

void account_confirm_char(P_desc d, char *arg)
{
  struct acct_chars *c = NULL;
  P_char ch = NULL;

  if (!arg || !*arg)
  {
    SEND_TO_Q("Play this character? (Y/N) ", d);
    return;
  }

  // Handle 'No' or cancel
  if (arg[0] == 'n' || arg[0] == 'N')
  {
    if (d->selected_char_name)
    {
      str_free(d->selected_char_name);
      d->selected_char_name = NULL;
    }
    SEND_TO_Q("\r\n", d);
    display_character_list(d);
    STATE(d) = CON_ACCT_SELECT_CHAR;
    return;
  }

  // Handle 'Yes'
  if (arg[0] == 'y' || arg[0] == 'Y')
  {
    if (!d->selected_char_name)
    {
      SEND_TO_Q("&+RError: No character selected.&n\r\n", d);
      display_character_list(d);
      STATE(d) = CON_ACCT_SELECT_CHAR;
      return;
    }

    // Find the character
    c = find_char_in_list(d->account->acct_character_list, d->selected_char_name);

    if (!c)
    {
      SEND_TO_Q("&+RSorry, I couldn't find that character!&n\r\n", d);
      if (d->selected_char_name)
      {
        str_free(d->selected_char_name);
        d->selected_char_name = NULL;
      }
      display_character_list(d);
      STATE(d) = CON_ACCT_SELECT_CHAR;
      return;
    }

    // Verify can still connect (double-check racewar timer, etc.)
    if (!can_connect(c, d))
    {
      char buf[512];
      int current_time = time(NULL);
      int time_remaining = 0;
      int minutes_remaining = 0;

      if (c->racewar == ACCT_GOOD && current_time < (d->account->acct_evil + 3600))
      {
        time_remaining = (d->account->acct_evil + 3600) - current_time;
        minutes_remaining = (time_remaining + 59) / 60;
        snprintf(buf, 512,
          "\r\n&+RSorry, you cannot play this Good-aligned character yet!&n\r\n"
          "You must wait &+Y%d&n more minute%s before playing a Good character.\r\n",
          minutes_remaining, minutes_remaining == 1 ? "" : "s");
        SEND_TO_Q(buf, d);
      }
      else if (c->racewar == ACCT_EVIL && current_time < (d->account->acct_good + 3600))
      {
        time_remaining = (d->account->acct_good + 3600) - current_time;
        minutes_remaining = (time_remaining + 59) / 60;
        snprintf(buf, 512,
          "\r\n&+RSorry, you cannot play this Evil-aligned character yet!&n\r\n"
          "You must wait &+Y%d&n more minute%s before playing an Evil character.\r\n",
          minutes_remaining, minutes_remaining == 1 ? "" : "s");
        SEND_TO_Q(buf, d);
      }
      else if (c->blocked)
      {
        SEND_TO_Q("\r\n&+RThis character has been blocked and cannot be played.&n\r\n", d);
      }

      if (d->selected_char_name)
      {
        str_free(d->selected_char_name);
        d->selected_char_name = NULL;
      }
      display_character_list(d);
      STATE(d) = CON_ACCT_SELECT_CHAR;
      return;
    }

    // Check if character is already in game
    if (is_char_in_game(c, d))
    {
      if (d->selected_char_name)
      {
        str_free(d->selected_char_name);
        d->selected_char_name = NULL;
      }
      return;
    }

    // Load character into game
    ch = load_char_into_game(c, d);

    if (!ch)
    {
      SEND_TO_Q("&+RSorry, I couldn't load that character!&n\r\n", d);
      if (d->selected_char_name)
      {
        str_free(d->selected_char_name);
        d->selected_char_name = NULL;
      }
      display_character_list(d);
      STATE(d) = CON_ACCT_SELECT_CHAR;
      return;
    }

    // Clean up temporary storage
    if (d->selected_char_name)
    {
      str_free(d->selected_char_name);
      d->selected_char_name = NULL;
    }

    // Show MOTD and enter game
    if (IS_TRUSTED(ch))
      SEND_TO_Q(wizmotd.c_str(), d);
    else
      SEND_TO_Q(motd.c_str(), d);

    echo_on(d);
    STATE(d) = CON_PLAYING;
    d->character = ch;
    enter_game(d);
    d->prompt_mode = TRUE;

    return;
  }

  // Invalid input
  SEND_TO_Q("Please answer (Y/N): ", d);
  return;
}

// Helper structure for character display data
struct char_display_info {
  char charname[32];
  int level;
  int secondary_level;
  int race;
  unsigned int m_class;
  unsigned int secondary_class;
  char *rested_status;  // "Well-Rested", "Rested", or "None"
  int hometown;  // Last room character was in
  long last_login;
};

// Helper function to load character display data
// Returns 1 on success, 0 on failure
int load_char_display_data(char *charname, struct char_display_info *info)
{
  P_char temp_ch;
  int result;

  // Create temporary character structure using malloc (like pfile.c does)
  temp_ch = (struct char_data *) malloc(sizeof(struct char_data));
  if (!temp_ch)
    return 0;

  memset(temp_ch, 0, sizeof(struct char_data));

  temp_ch->only.pc = (struct pc_only_data *) malloc(sizeof(struct pc_only_data));
  if (!temp_ch->only.pc)
  {
    free(temp_ch);
    return 0;
  }

  memset(temp_ch->only.pc, 0, sizeof(struct pc_only_data));

  // Load character data
  result = restoreCharOnly(temp_ch, charname);
  if (result < 0)
  {
    if (temp_ch->only.pc)
      free(temp_ch->only.pc);
    free(temp_ch);
    return 0;
  }

  // Extract display data
  strncpy(info->charname, GET_NAME(temp_ch), 31);
  info->charname[31] = '\0';
  info->level = GET_LEVEL(temp_ch);
  info->secondary_level = GET_SECONDARY_LEVEL(temp_ch);
  info->race = GET_RACE(temp_ch);
  info->m_class = temp_ch->player.m_class;
  info->secondary_class = temp_ch->player.secondary_class;
  info->hometown = GET_HOME(temp_ch);

  // Calculate rested status based on offline time (same logic as nanny.c)
  time_t current_time = time(0);
  time_t offline_seconds = current_time - temp_ch->player.time.saved;
  int offline_hours = offline_seconds / 3600;
  char rested_buf[128];

  if (offline_hours >= 20)
  {
    // Well-rested bonus
    snprintf(rested_buf, 128, "&+Wwell-rested&n bonus (&+G%d&n hours offline)", offline_hours);
    info->rested_status = str_dup(rested_buf);
  }
  else if (offline_hours >= 9)
  {
    // Rested bonus
    snprintf(rested_buf, 128, "&+Grested&n bonus (&+Y%d&n hours offline)", offline_hours);
    info->rested_status = str_dup(rested_buf);
  }
  else
  {
    // No bonus yet - show how many more hours needed
    int hours_needed = 9 - offline_hours;
    snprintf(rested_buf, 128, "&+LNone&n (&+R%d&n more hour%s needed)", hours_needed, hours_needed == 1 ? "" : "s");
    info->rested_status = str_dup(rested_buf);
  }

  // Clean up temporary character
  if (temp_ch->only.pc)
    free(temp_ch->only.pc);
  free(temp_ch);

  return 1;
}

// Helper function to get race name from character display info
void get_race_name_from_info(struct char_display_info *info, char *race_str, int max_len)
{
  extern const struct race_names race_names_table[];
  if (info->race >= 0 && info->race < LAST_RACE)
  {
    strncpy(race_str, race_names_table[info->race].normal, max_len - 1);
    race_str[max_len - 1] = '\0';
  }
  else
  {
    strncpy(race_str, "Unknown", max_len - 1);
    race_str[max_len - 1] = '\0';
  }
}

void check_rested_bonus(P_desc d)
{
  struct acct_chars *c = d->account->acct_character_list;
  char buf[512];
  int count = 0;

  SEND_TO_Q("\r\n&+y===== &+WRESTED BONUS STATUS&+y =====&n\r\n\r\n", d);

  while (c)
  {
    struct char_display_info info;

    if (load_char_display_data(c->charname, &info))
    {
      // Capitalize character name
      char name_cap[32];
      strncpy(name_cap, info.charname, 31);
      name_cap[31] = '\0';
      if (name_cap[0])
        name_cap[0] = toupper(name_cap[0]);

      snprintf(buf, 512, "&+C%-12s&n: %s\r\n", name_cap,
               info.rested_status ? info.rested_status : "&+LNone&n");
      SEND_TO_Q(buf, d);

      if (info.rested_status)
        str_free(info.rested_status);

      count++;
    }
    c = c->next;
  }

  if (count == 0)
  {
    SEND_TO_Q("&+LNo characters found.&n\r\n", d);
  }

  SEND_TO_Q("\r\n", d);
  display_account_menu(d, NULL);
}

void display_delete_character_list(P_desc d)
{
  struct acct_chars *c = d->account->acct_character_list;
  struct acct_chars *sorted_chars[MAX_CHARS_PER_ACCOUNT];
  char     buf[256];
  int      count = 0, i, j;
  struct acct_chars *temp;

  // Enable ANSI terminal mode for color display
  d->term_type = TERM_ANSI;

  if (!c)
  {
    snprintf(buf, 256, "You currently don't have any characters to delete.\r\n");
    SEND_TO_Q(buf, d);
    STATE(d) = CON_DISPLAY_ACCT_MENU;
    display_account_menu(d, NULL);
    return;
  }

  // Count characters and build array for sorting
  temp = c;
  while (temp && count < MAX_CHARS_PER_ACCOUNT)
  {
    sorted_chars[count++] = temp;
    temp = temp->next;
  }

  // Sort by last login time (most recent first) - simple bubble sort
  for (i = 0; i < count - 1; i++)
  {
    for (j = 0; j < count - i - 1; j++)
    {
      if (sorted_chars[j]->last < sorted_chars[j+1]->last)
      {
        struct acct_chars *swap = sorted_chars[j];
        sorted_chars[j] = sorted_chars[j+1];
        sorted_chars[j+1] = swap;
      }
    }
  }

  // Display large warning banner in bright red
  SEND_TO_Q("\r\n", d);
  SEND_TO_Q("&+R/===========================================================================\\&n\r\n", d);
  SEND_TO_Q("&+R|                                                                           |&n\r\n", d);
  SEND_TO_Q("&+R|                         !!!  W A R N I N G  !!!                          |&n\r\n", d);
  SEND_TO_Q("&+R|                                                                           |&n\r\n", d);
  SEND_TO_Q("&+R|                  CHARACTER DELETION IS PERMANENT!                        |&n\r\n", d);
  SEND_TO_Q("&+R|                                                                           |&n\r\n", d);
  SEND_TO_Q("&+R|       Once deleted, your character CANNOT be recovered or restored!      |&n\r\n", d);
  SEND_TO_Q("&+R|                                                                           |&n\r\n", d);
  SEND_TO_Q("&+R\\===========================================================================/&n\r\n", d);
  SEND_TO_Q("\r\n", d);

  // Display table header
  SEND_TO_Q("&+R/-------------------------------------------------------\\&n\r\n", d);

  char title_buf[256];
  snprintf(title_buf, 256, "DELETE CHARACTER (%d character%s)", count, count == 1 ? "" : "s");
  int title_len = strlen(title_buf);
  int left_pad = (57 - title_len) / 2;
  int right_pad = 57 - title_len - left_pad - 2;

  snprintf(buf, 256, "&+R|%*s&+W%s%*s&+R|&n\r\n", left_pad, "", title_buf, right_pad, "");
  SEND_TO_Q(buf, d);

  SEND_TO_Q("&+R|=======================================================|&n\r\n", d);
  SEND_TO_Q("&+R|&n # &+R|&n &+RCharacter    &+R|&n &+RLevel &+R|&n &+RRace         &+R|&n &+RClass&n        &+R|&n\r\n", d);
  SEND_TO_Q("&+R|-------------------------------------------------------|&n\r\n", d);

  // Display sorted characters in red
  for (i = 0; i < count; i++)
  {
    struct char_display_info info;
    char name_capitalized[32];
    char race_str[32];
    char class_str[64];
    char level_str[16];
    char line_buf[512];

    // Load character display data
    if (!load_char_display_data(sorted_chars[i]->charname, &info))
    {
      snprintf(line_buf, 512, "&+R|&n &+R%d&n &+R|&n &+R%-12s&n &+R|&n &+R%-5s&n &+R|&n &+R%-12s&n &+R|&n &+R%-12s&n &+R|&n\r\n",
               i + 1, sorted_chars[i]->charname, "?", "?", "?");
      SEND_TO_Q(line_buf, d);
      continue;
    }

    // Capitalize character name
    strncpy(name_capitalized, info.charname, 31);
    name_capitalized[31] = '\0';
    if (name_capitalized[0])
      name_capitalized[0] = toupper(name_capitalized[0]);

    // Get race name
    get_race_name_from_info(&info, race_str, 32);

    // Get class name(s)
    extern const struct class_names class_names_table[];
    int primary_idx = flag2idx(info.m_class);
    int secondary_idx = info.secondary_class ? flag2idx(info.secondary_class) : 0;

    if (info.secondary_class && secondary_idx > 0)
    {
      // Multiclass
      snprintf(level_str, 16, "%d/%d", info.level, info.secondary_level);
      snprintf(class_str, 64, "%s/%s",
               class_names_table[primary_idx].normal,
               class_names_table[secondary_idx].normal);
    }
    else
    {
      // Single class
      snprintf(level_str, 16, "%d", info.level);
      strncpy(class_str, class_names_table[primary_idx].normal, 63);
      class_str[63] = '\0';
    }

    // Truncate strings if too long
    if (strlen(name_capitalized) > 12)
      name_capitalized[12] = '\0';
    if (strlen(race_str) > 12)
      race_str[12] = '\0';
    if (strlen(class_str) > 12)
      class_str[12] = '\0';

    // Display character row in bright red
    snprintf(line_buf, 512, "&+R|&n %d &+R|&n &+R%-12s&n &+R|&n &+R%-5s&n &+R|&n &+R%-12s&n &+R|&n &+R%-12s&n &+R|&n\r\n",
             i + 1, name_capitalized, level_str, race_str, class_str);
    SEND_TO_Q(line_buf, d);

    // Free rested status string
    if (info.rested_status)
      str_free(info.rested_status);
  }

  // Display table footer
  SEND_TO_Q("&+R\\-------------------------------------------------------/&n\r\n", d);
  SEND_TO_Q("\r\n&+W0&n) &+GCancel and return to Account Menu&n\r\n\r\n", d);
  SEND_TO_Q("Which character do you want to &+RDELETE&n? (Enter number or 0 to cancel): ", d);
}

void display_character_list(P_desc d)
{
  struct acct_chars *c = d->account->acct_character_list;
  struct acct_chars *sorted_chars[MAX_CHARS_PER_ACCOUNT];
  char     buf[256];
  int      count = 0, i, j;
  struct acct_chars *temp;

  // Enable ANSI terminal mode for color display
  d->term_type = TERM_ANSI;

  if (!c)
  {
    snprintf(buf, 256, "You currently don't have any characters (0/%d).\r\n", MAX_CHARS_PER_ACCOUNT);
    SEND_TO_Q(buf, d);
    STATE(d) = CON_DISPLAY_ACCT_MENU;
    display_account_menu(d, NULL);
    return;
  }

  // Count characters and build array for sorting
  temp = c;
  while (temp && count < MAX_CHARS_PER_ACCOUNT)
  {
    sorted_chars[count++] = temp;
    temp = temp->next;
  }

  // Sort by last login time (most recent first) - simple bubble sort
  for (i = 0; i < count - 1; i++)
  {
    for (j = 0; j < count - i - 1; j++)
    {
      if (sorted_chars[j]->last < sorted_chars[j+1]->last)
      {
        struct acct_chars *swap = sorted_chars[j];
        sorted_chars[j] = sorted_chars[j+1];
        sorted_chars[j+1] = swap;
      }
    }
  }

  // Display table header
  SEND_TO_Q("\r\n", d);
  SEND_TO_Q("&+y/---------------------------------------------------------------------------\\&n\r\n", d);

  // Build CHARACTER SELECTION line with proper padding
  char title_buf[256];
  int title_len;
  snprintf(title_buf, 256, "CHARACTER SELECTION (%d/%d)", count, MAX_CHARS_PER_ACCOUNT);
  title_len = strlen(title_buf);
  int left_pad = (77 - title_len) / 2;
  int right_pad = 77 - title_len - left_pad-2;

  snprintf(buf, 256, "&+y|%*s&+W%s%*s&+y|&n\r\n", left_pad, "", title_buf, right_pad, "");
  SEND_TO_Q(buf, d);

  SEND_TO_Q("&+y|===========================================================================|&n\r\n", d);
  SEND_TO_Q("&+y|&n # &+y|&n Character    &+y|&n Level &+y|&n Race         &+y|&n Class        &+y|&n Last Room        &+y|&n\r\n", d);
  SEND_TO_Q("&+y|---------------------------------------------------------------------------|&n\r\n", d);

  // Display sorted characters
  for (i = 0; i < count; i++)
  {
    struct char_display_info info;
    char name_capitalized[32];
    char race_str[32];
    char class_str[64];
    char level_str[16];
    char line_buf[512];  // Larger buffer for color codes

    // Load character display data
    if (!load_char_display_data(sorted_chars[i]->charname, &info))
    {
      snprintf(line_buf, 512, "&+y|&n &+C%d&n &+y|&n &+W%-12s&n &+y|&n &+R%-5s&n &+y|&n &+R%-12s&n &+y|&n &+R%-12s&n &+y|&n &+R?&n\r\n",
               i + 1, sorted_chars[i]->charname, "?", "?", "?");
      SEND_TO_Q(line_buf, d);
      continue;
    }

    // Capitalize character name
    strncpy(name_capitalized, info.charname, 31);
    name_capitalized[31] = '\0';
    if (name_capitalized[0])
      name_capitalized[0] = toupper(name_capitalized[0]);

    // Get race name
    get_race_name_from_info(&info, race_str, 32);

    // Get class name(s) - with bounds checking
    extern const struct class_names class_names_table[];
    int primary_idx = flag2idx(info.m_class);
    int secondary_idx = info.secondary_class ? flag2idx(info.secondary_class) : 0;

    if (info.secondary_class && secondary_idx > 0)
    {
      // Multiclass
      snprintf(level_str, 16, "%d/%d", info.level, info.secondary_level);
      snprintf(class_str, 64, "%s/%s",
               class_names_table[primary_idx].normal,
               class_names_table[secondary_idx].normal);
    }
    else
    {
      // Single class
      snprintf(level_str, 16, "%d", info.level);
      strncpy(class_str, class_names_table[primary_idx].normal, 63);
      class_str[63] = '\0';
    }

    // Truncate strings if too long for table
    if (strlen(name_capitalized) > 12)
      name_capitalized[12] = '\0';
    if (strlen(race_str) > 12)
      race_str[12] = '\0';
    if (strlen(class_str) > 12)
      class_str[12] = '\0';

    // Get room name with its original ANSI color intact
    const char *room_name_src;
    char room_display[128];
    if (info.hometown >= 0 && info.hometown < top_of_world && world[info.hometown].name)
    {
      room_name_src = world[info.hometown].name;
    }
    else
    {
      room_name_src = "Unknown";
    }

    // Truncate room name to fit column (16 visible chars) while preserving ANSI codes
    int src_idx = 0, dst_idx = 0, visible_count = 0;
    int max_visible = 16;
    while (room_name_src[src_idx] && dst_idx < 126)
    {
      if (room_name_src[src_idx] == '&' && room_name_src[src_idx + 1])
      {
        // Copy ANSI code without counting it
        room_display[dst_idx++] = room_name_src[src_idx++];
        room_display[dst_idx++] = room_name_src[src_idx++];
        if (room_name_src[src_idx - 1] == '+' || room_name_src[src_idx - 1] == '-')
        {
          if (room_name_src[src_idx])
            room_display[dst_idx++] = room_name_src[src_idx++];
        }
      }
      else
      {
        // Regular character - count it
        if (visible_count >= max_visible)
          break;
        room_display[dst_idx++] = room_name_src[src_idx++];
        visible_count++;
      }
    }
    room_display[dst_idx] = '\0';

    // Display character row
    snprintf(line_buf, 512, "&+y|&n %d &+y|&n %-12s &+y|&n %-5s &+y|&n %-12s &+y|&n %-12s &+y|&n %s &+y|&n\r\n",
             i + 1, name_capitalized, level_str, race_str, class_str, room_display);
    SEND_TO_Q(line_buf, d);

    // Free rested status string using str_free (not free)
    if (info.rested_status)
      str_free(info.rested_status);
  }

  // Display table footer
  SEND_TO_Q("&+y\\---------------------------------------------------------------------------/&n\r\n", d);
  SEND_TO_Q("\r\n&+W0&n) &+LBack to Account Menu&n\r\n\r\n", d);
  SEND_TO_Q("Which character would you like to play? ", d);
}




int can_connect(struct acct_chars *c, P_desc d)
{
  int      current_time = time(NULL);

  if (c->blocked)
    return 0;

  if ((c->racewar == ACCT_IMMORTAL))
    return 1;

  if ((c->racewar == ACCT_GOOD) &&
      (current_time < (d->account->acct_evil + 3600)))
    return 0;

  if ((c->racewar == ACCT_EVIL) &&
      (current_time < (d->account->acct_good + 3600)))
    return 0;

  return 1;
}


int is_char_in_game(struct acct_chars *c, P_desc d)
{
  P_desc   k = descriptor_list;
  P_desc   x = NULL;
  P_char   ch = character_list;

  for (; k; k = k->next)
  {
    if ((k != d) && k->character && GET_NAME(k->character) &&
        !strcasecmp(GET_NAME(k->character), c->charname))
    {
      // ok, same character, take over the descriptor
      d->character = k->character;
      d->character->desc = d;
      close_socket(k);
      SEND_TO_Q("Overriding old connection...\r\n", d);
    }
  }

  for (; ch; ch = ch->next)
  {
    if (IS_PC(ch) && !ch->desc && GET_NAME(ch) &&
        !strcasecmp(GET_NAME(ch), c->charname))
    {
      echo_on(d);
      SEND_TO_Q("Reconnecting...\r\n", d);
      act("$n has reconnected.", TRUE, ch, 0, 0, TO_ROOM);
      d->character = ch;
      ch->desc = d;
      // sql_update_playerIP(ch);  // Deprecated function
      ch->specials.timer = 0;
      STATE(d) = CON_PLAYING;

      logit(LOG_COMM, "%s [%s@%s] has reconnected.", GET_NAME(d->character),
            d->login, d->host);
      loginlog(d->character->player.level, "%s [%s@%s] has reconnected.",
               GET_NAME(d->character), d->login, d->host);
      // sql_log(ch, CONNECT_LOG, "Reconnected");  // Deprecated function

#if 0
      /* panic, lets check for spellcast events and nuke them, hopefully allowing a release from
         spellcast bug */
      if (IS_AFFECTED2(d->character, AFF2_CASTING))
      {
        P_event  ev;

        LOOP_EVENTS(ev, (d->character)->events)
          if (ev->type == EVENT_SPELLCAST)
        {
          statuslog(AVATAR, "Spellcast bug on %s aborted",
                    GET_NAME(d->character));
          StopCasting(d->character);
        }
      }
      /* if they were morph'ed when they lost link, put them
         back... */
#endif
      if (IS_SET(ch->specials.act, PLR_MORPH))
      {
        if (!ch->only.pc->switched || !IS_MORPH(ch->only.pc->switched) ||
            /*              (ch != ((P_char)
               ch->only.pc->switched->only.npc->memory))) */
            (ch != ch->only.pc->switched->only.npc->orig_char))
        {
          logit(LOG_EXIT,
                "Something fucked while trying to reconnect linkless morph");
          raise(SIGSEGV);
        }
        d->original = ch;
        d->character = ch->only.pc->switched;
        d->character->desc = d;
        ch->desc = NULL;
      }
      return 1;
    }
  }
  return 0;
}

struct acct_chars *find_char_in_list(struct acct_chars *list, char *arg)
{
  struct acct_chars *c = NULL;

  if (!list)
    return NULL;

  while (list)
  {
    if (!strcasecmp(list->charname, arg))
      return list;
    else
      list = list->next;
  }
  return NULL;
}

P_char load_char_into_game(struct acct_chars * c, P_desc d)
{

  P_char   player = NULL;
  int      status = 0;

  player = (P_char) mm_get(dead_mob_pool);

  clear_char(player);

  if (!dead_pconly_pool)
    dead_pconly_pool = mm_create("PC_ONLY",
                                 sizeof(struct pc_only_data),
                                 offsetof(struct pc_only_data, switched),
                                 mm_find_best_chunk(sizeof
                                                    (struct pc_only_data), 10,
                                                    25));

  player->only.pc = (struct pc_only_data *) mm_get(dead_pconly_pool);
  player->desc = d;

  setCharPhysTypeInfo(player);
  status = restoreCharOnly(player, c->charname);

  if (status == -1)
  {
    SEND_TO_Q("Couldn't find that pfile!\r\n", d);
    STATE(d) = CON_DISPLAY_ACCT_MENU;
    display_account_menu(d, NULL);
    return NULL;
  }
  else if (status == -2)
  {
    SEND_TO_Q("There was an error reading your pfile!\r\n", d);
    STATE(d) = CON_DISPLAY_ACCT_MENU;
    display_account_menu(d, NULL);
    return NULL;
  }
  else
  {
    d->rtype = status;
    return player;
  }
}

void account_new_char(P_desc d, char *arg)
{
  SEND_TO_Q("Enter your new name:  ", d);
  STATE(d) = CON_ACCT_NEW_CHAR_NAME;
  return;
}

void account_new_char_name(P_desc d, char *arg)
{
  P_char   player = NULL;
  char     tmp_name[1024];

  if (!arg)
  {
    STATE(d) = CON_DISPLAY_ACCT_MENU;
    display_account_menu(d, NULL);
    return;
  }

  // Check if account has reached character limit
  if (d->account->num_chars >= MAX_CHARS_PER_ACCOUNT)
  {
    SEND_TO_Q("\r\n&+RYou already have the maximum number of characters allowed per account.&n\r\n", d);
    SEND_TO_Q("Please delete a character before creating a new one.\r\n\r\n", d);
    STATE(d) = CON_DISPLAY_ACCT_MENU;
    display_account_menu(d, NULL);
    return;
  }

  for (; isspace(*arg); arg++) ;

  if (_parse_name(arg, tmp_name))
  {
    SEND_TO_Q("Illegal account name, please try another.\r\n", d);
    SEND_TO_Q("Account Name: ", d);
    return;
  }

  arg = tmp_name;

  if (!account_exists(SAVE_DIR, arg) &&
      account_exists(BADNAME_DIR, arg))
  {
    SEND_TO_Q
      ("That name has been declined before, and would be now too!\r\nName:",
       d);
    return;
  }
  if (account_exists(SAVE_DIR, arg))
  {
    SEND_TO_Q("Name is in use already. Please enter new name.\r\nName:", d);
    return;
  }
  else if (account_exists(BADNAME_DIR, arg))
  {
    SEND_TO_Q
      ("That name has been declined before, and would be now too!\r\nName:",
       d);
    return;
  }
  if (IS_SET(game_locked, LOCK_CREATION))
  {
    SEND_TO_Q("Game is currently not allowing creation of new characters.\r\n"
              "Please use an existing character, or try again later.\r\n\r\n",
              d);
    STATE(d) = CON_DISPLAY_ACCT_MENU;
    display_account_menu(d, NULL);
    return;
  }
  else if (bannedsite(d->host, 1))
  {
    SEND_TO_Q
      ("New characters have been banned from your site. If you want the ban lifted\r\n"
       "mail duris@duris.org with a _LENGTHY_ explanation about\r\n"
       "why, or who could have forced us to ban the site in the first place.\r\n"
       "          - The Management \r\n\r\n", d);
    banlog(AVATAR, "&+yNew Character reject from %s, banned.", d->host);
    STATE(d) = CON_DISPLAY_ACCT_MENU;
    display_account_menu(d, NULL);
    return;
  }
  else if ((game_locked & LOCK_CONNECTIONS) ||
           ((game_locked & LOCK_MAX_PLAYERS) &&
            (number_of_players() >= MAX_PLAYERS_BEFORE_LOCK)))
  {
    SEND_TO_Q("Game is temporarily full.  Please try again later.\r\n", d);
    STATE(d) = CON_DISPLAY_ACCT_MENU;
    display_account_menu(d, NULL);
    return;
  }

  // Ok, we got this far, so it's ok to make a character, yay!
  if (d->character)
  {
    player = d->character;
  }
  else
  {
    player = (P_char) mm_get(dead_mob_pool);

    clear_char(player);

    if (!dead_pconly_pool)
      dead_pconly_pool = mm_create("PC_ONLY",
                                   sizeof(struct pc_only_data),
                                   offsetof(struct pc_only_data, switched),
                                   mm_find_best_chunk(sizeof
                                                      (struct pc_only_data),
                                                      10, 25));

    player->only.pc = (struct pc_only_data *) mm_get(dead_pconly_pool);
    player->desc = d;

    setCharPhysTypeInfo(player);

    d->character = player;
  }

  strcpy(d->character->only.pc->pwd, d->account->acct_password);
  d->character->player.name = str_dup(arg);
  *d->character->player.name = toupper(*d->character->player.name);
  SEND_TO_Q("You chose the name ", d);
  SEND_TO_Q(d->character->player.name, d);
  SEND_TO_Q("  Is this correct?  (Y/N)  ", d);
  STATE(d) = CON_NAME_CONF;
  return;
}

void add_char_to_account(P_desc d)
{
  P_char   player = d->character;
  struct acct_chars *c = NULL;

  CREATE(c, acct_chars, 1, MEM_TAG_OTHER);

  c->charname = str_dup(player->player.name);
  c->count = 1;
  c->last = time(NULL);
  c->blocked = 0;
  if (EVIL_RACE(player))
    c->racewar = ACCT_EVIL;
  else
    c->racewar = ACCT_GOOD;
  c->next = d->account->acct_character_list;
  d->account->acct_character_list = c;
  write_account(d->account);
}


void account_delete_char(P_desc d, char *arg)
{
  P_char   ch = NULL;
  struct acct_chars *c = NULL;
  struct acct_chars *sorted_chars[MAX_CHARS_PER_ACCOUNT];
  struct acct_chars *temp;
  char     buf[256];
  int      selection, count = 0, i, j;

  if (!arg)
  {
    // First call - display the character list
    display_delete_character_list(d);
    return;
  }

  // Check if confirming deletion (yes/no)
  if (!strcasecmp(arg, "y") || !strcasecmp(arg, "yes"))
  {
    if (!d->character)
    {
      SEND_TO_Q("\r\n&+ROdd, couldn't delete that char.&n\r\n", d);
      STATE(d) = CON_DISPLAY_ACCT_MENU;
      display_account_menu(d, NULL);
      return;
    }
    SEND_TO_Q("\r\n&+RDeleting character...&n\r\n\r\n", d);
    statuslog(d->character->player.level, "%s deleted %sself (%s@%s).",
              GET_NAME(d->character),
              GET_SEX(d->character) == SEX_MALE ? "him" : "her", d->login,
              d->host);
    logit(LOG_PLAYER, "%s deleted %sself (%s@%s).", GET_NAME(d->character),
          GET_SEX(d->character) == SEX_MALE ? "him" : "her", d->login,
          d->host);
    deleteCharacter(d->character);
    d->character = NULL;  // Clear dangling pointer
    d->term_type = TERM_ANSI;  // Preserve ANSI terminal mode
    SEND_TO_Q("&+GCharacter deleted successfully.&n\r\n\r\n", d);
    STATE(d) = CON_DISPLAY_ACCT_MENU;
    display_account_menu(d, NULL);
    return;
  }
  else if (!strcasecmp(arg, "n") || !strcasecmp(arg, "no"))
  {
    SEND_TO_Q("\r\n&+GDeletion cancelled.&n\r\n", d);
    STATE(d) = CON_DISPLAY_ACCT_MENU;
    display_account_menu(d, NULL);
    return;
  }

  // Check if user wants to go back (0 or "back")
  if (!strcasecmp(arg, "0") || !strcasecmp(arg, "back"))
  {
    STATE(d) = CON_DISPLAY_ACCT_MENU;
    display_account_menu(d, NULL);
    return;
  }

  // Parse numeric selection
  selection = atoi(arg);

  if (selection <= 0)
  {
    SEND_TO_Q("\r\n&+RInvalid selection.&n Please enter a number or 0 to cancel.\r\n", d);
    display_delete_character_list(d);
    return;
  }

  // Build sorted character list (same sorting as display)
  temp = d->account->acct_character_list;
  while (temp && count < MAX_CHARS_PER_ACCOUNT)
  {
    sorted_chars[count++] = temp;
    temp = temp->next;
  }

  // Sort by last login time (most recent first)
  for (i = 0; i < count - 1; i++)
  {
    for (j = 0; j < count - i - 1; j++)
    {
      if (sorted_chars[j]->last < sorted_chars[j+1]->last)
      {
        struct acct_chars *swap = sorted_chars[j];
        sorted_chars[j] = sorted_chars[j+1];
        sorted_chars[j+1] = swap;
      }
    }
  }

  // Validate selection range
  if (selection > count)
  {
    SEND_TO_Q("\r\n&+RInvalid selection.&n Please choose a number from the list.\r\n", d);
    display_delete_character_list(d);
    return;
  }

  // Get the selected character (adjust for 0-based indexing)
  c = sorted_chars[selection - 1];
  ch = load_char_into_game(c, d);

  if (!ch)
  {
    SEND_TO_Q("\r\n&+RCouldn't load that character!&n\r\n", d);
    STATE(d) = CON_DISPLAY_ACCT_MENU;
    display_account_menu(d, NULL);
    return;
  }

  // Capitalize character name for display
  char name_cap[128];
  strncpy(name_cap, c->charname, 127);
  name_cap[127] = '\0';
  if (name_cap[0])
    name_cap[0] = toupper(name_cap[0]);

  // Confirm deletion
  snprintf(buf, 256, "\r\n&+R!!! FINAL WARNING !!!&n\r\n"
           "Are you &+RABSOLUTELY SURE&n you want to &+RPERMANENTLY DELETE&n &+W%s&n?\r\n"
           "This action &+RCANNOT BE UNDONE!&n\r\n\r\n"
           "Type &+WYES&n to confirm deletion, or &+WNO&n to cancel: ", name_cap);
  SEND_TO_Q(buf, d);
  d->character = ch;
  return;
}

void remove_char_from_list(P_acct acct, char *ch)
{
  struct acct_chars *c = NULL;
  struct acct_chars *d = NULL;

  c = acct->acct_character_list;
  if (!strcasecmp(ch, c->charname))
  {
    acct->acct_character_list = c->next;
    FREE(c->charname);
    FREE(c);
    write_account(acct);
    return;
  }

  while (c)
  {
    if (!strcasecmp(ch, c->charname))
    {
      d->next = c->next;
      FREE(c->charname);
      FREE(c);
      write_account(acct);
      return;
    }
    d = c;
    c = c->next;
  }
}

void account_display_info(P_desc d, char *arg)
{
  display_account_information(d);
  STATE(d) = CON_DISPLAY_ACCT_MENU;
  display_account_menu(d, NULL);
  return;
}

void delete_account(P_desc d, char *arg)
{

}

void verify_delete_account(P_desc d, char *arg)
{

}

int read_account(P_acct acct)   // returns -1 if error, 1 if no errors
{
  FILE    *f = NULL;
  char     name[4096], filename[4096], buf[4096], *ptr = NULL;
  int      serial = 0;


  snprintf(name, 4096, "%s", acct->acct_name);
  ptr = name;

  for (; *ptr; ptr++)
    *ptr = LOWER(*ptr);

  snprintf(buf, 4096, "Accounts/%c/%s", (*name), name);
  logit(LOG_FILE, "Loading Account %s in %s.", name, buf);

  f = fopen(buf, "r");

  if (!f)
  {
    logit(LOG_FILE, "Couldn't open Account file: %s", buf);
    return -1;
  }

  fscanf(f, "%d\n", &serial);
  fgets(buf, 4096, f);
  buf[strcspn(buf, "\r\n")] = 0;  // Remove newline
  acct->acct_name = str_dup(buf);
  fgets(buf, 4096, f);
  buf[strcspn(buf, "\r\n")] = 0;
  acct->acct_email = str_dup(buf);
  fgets(buf, 4096, f);
  buf[strcspn(buf, "\r\n")] = 0;
  acct->acct_password = str_dup(buf);
  fgets(buf, 4096, f);
  buf[strcspn(buf, "\r\n")] = 0;
  acct->acct_confirmation = str_dup(buf);

  read_unique_ip(acct, f);
  read_character_list(acct, f);

  fscanf(f, "%hhd\n", &acct->acct_blocked);
  fscanf(f, "%hhd\n", &acct->acct_confirmed);
  fscanf(f, "%hhd\n", &acct->acct_confirmation_sent);

  fscanf(f, "%li\n", &acct->acct_last);
  fscanf(f, "%li\n", &acct->acct_good);
  fscanf(f, "%li\n", &acct->acct_evil);
  fscanf(f, "%li\n", &acct->acct_flags1);
  fscanf(f, "%li\n", &acct->acct_flags2);
  fscanf(f, "%li\n", &acct->acct_flags3);
  fscanf(f, "%li\n", &acct->acct_flags4);

  fclose(f);
  return 1;
}

int write_account(P_acct acct)  // returns -1 if error, 1 if no errors
{
  FILE    *f = NULL;
  char     buf[4096], name[4096], *ptr = NULL;
  struct stat statbuf;
  P_desc   d = NULL;

  if (!acct)
    return -1;

  snprintf(name, 4096, "%s", acct->acct_name);

  ptr = name;

  for (; *ptr; ptr++)
    *ptr = LOWER(*ptr);

  snprintf(buf, 4096, "Accounts/%c/%s", (*name), name);
  logit(LOG_FILE, "Saving Account %s in %s.", name, buf);
  snprintf(name, 4096, "%s.bak", buf);


  if (stat(buf, &statbuf) == 0)
  {
    if (rename(buf, name) == -1)
    {
      logit(LOG_FILE, "Problem with player save files directory!\n");
      wizlog(AVATAR, "&+R&-LPANIC!&N  Error backing up account for %s!",
             acct->acct_name);
      return -1;
    }
  }

  f = fopen(buf, "w");
  if (!f)
  {
    logit(LOG_FILE, "Fopen failed while creating account file: %s\n", buf);
    return -1;
  }

  fprintf(f, "%d\n", ACCT_SERIAL);
  fprintf(f, "%s\n", acct->acct_name);
  fprintf(f, "%s\n", acct->acct_email);
  fprintf(f, "%s\n", acct->acct_password);
  fprintf(f, "%s\n", acct->acct_confirmation);

  write_unique_ip(acct, f);
  write_character_list(acct, f);

  fprintf(f, "%d\n", acct->acct_blocked);
  fprintf(f, "%d\n", acct->acct_confirmed);
  fprintf(f, "%d\n", acct->acct_confirmation_sent);

  fprintf(f, "%li\n", acct->acct_last);
  fprintf(f, "%li\n", acct->acct_good);
  fprintf(f, "%li\n", acct->acct_evil);
  fprintf(f, "%li\n", acct->acct_flags1);
  fprintf(f, "%li\n", acct->acct_flags2);
  fprintf(f, "%li\n", acct->acct_flags3);
  fprintf(f, "%li\n", acct->acct_flags4);


  fprintf(f, "###\n");
  fclose(f);
  for (d = descriptor_list; d; d = d->next)
  {
    if (d->account && !strcasecmp(acct->acct_name, d->account->acct_name))
      read_account(d->account);
  }
  return 1;
}

void write_unique_ip(P_acct acct, FILE * f)
{
  int      count = 0;
  struct acct_ip *c = NULL;

  c = acct->acct_unique_ips;
  if (!c)
  {
    fprintf(f, "0\n");
    return;
  }

  while (c)
  {
    count++;
    c = c->next;
  }

  fprintf(f, "%d\n", count);
  c = acct->acct_unique_ips;
  while (c)
  {
    fprintf(f, "%s\n%s\n%li\n", c->hostname, c->ip_address, c->count);
    c = c->next;
  }
}

void read_unique_ip(P_acct acct, FILE * f)
{
  int      count = 0;
  int      i;
  struct acct_ip *c = NULL;
  struct acct_ip *d = NULL;
  char     buf[256];

  fscanf(f, "%d\n", &count);
  if (count == 0)
    return;

  for (i = 0; i < count; i++)
  {
    CREATE(c, acct_ip, 1, MEM_TAG_OTHER);

    fscanf(f, "%s\n", buf);
    c->hostname = str_dup(buf);
    fscanf(f, "%s\n", buf);
    c->ip_address = str_dup(buf);
    fscanf(f, "%lu\n", &c->count);
    if (i == 0)
      acct->acct_unique_ips = c;
    if (d)
      d->next = c;
    d = c;
  }
}

void write_character_list(P_acct acct, FILE * f)
{
  int      count = 0;
  struct acct_chars *c = NULL;

  c = acct->acct_character_list;
  if (!c)
  {
    fprintf(f, "0\n");
    return;
  }

  while (c)
  {
    count++;
    c = c->next;
  }

  fprintf(f, "%d\n", count);
  c = acct->acct_character_list;
  while (c)
  {
    fprintf(f, "%s\n%li %li %d %d\n", c->charname, c->count, c->last,
            c->blocked, c->racewar);
    c = c->next;
  }
}

void read_character_list(P_acct acct, FILE * f)
{
  int      count = 0;
  int      i;
  struct acct_chars *c = NULL;
  struct acct_chars *d = NULL;
  char     buf[256];

  fscanf(f, "%d\n", &count);
  if (count == 0)
    return;

  for (i = 0; i < count; i++)
  {
    CREATE(c, acct_chars, 1, MEM_TAG_OTHER);

    fscanf(f, "%s\n", buf);
    c->charname = str_dup(buf);
    fscanf(f, "%lu %ld %hhd %hhd\n", &c->count, &c->last, &c->blocked, &c->racewar);
    if (i == 0)
      acct->acct_character_list = c;
    if (d)
      d->next = c;
    d = c;
  }

}





void generate_account_confirmation_code(P_desc d, char *arg)
{
  char     a[256], b[256];
  FILE    *f = NULL;

  snprintf(a, 256, "%d%ld", rand(), (long)time(NULL));
  snprintf(b, 256, "%s", CRYPT2(a, d->account->acct_name));

  d->account->acct_confirmation = str_dup(b);
  write_account(d->account);

  // Display confirmation code on screen
  char display_buf[1024];
  snprintf(display_buf, 1024,
    "\r\n&+Y========================================&n\r\n"
    "&+W*** Account Confirmation Code ***&n\r\n"
    "&+Y========================================&n\r\n\r\n"
    "Your confirmation code is: &+C%s&n\r\n\r\n"
    "&+YPLEASE WRITE THIS DOWN!&n\r\n"
    "&+Y========================================&n\r\n\r\n",
    d->account->acct_confirmation);
  SEND_TO_Q(display_buf, d);

#ifdef REQUIRE_EMAIL_VERIFICATION
  // Only send email if verification is enabled
  snprintf(a, 256, "/tmp/%s.confirmation", d->account->acct_name);
  f = fopen(a, "w");
  if (!f)
  {
    ereglog(AVATAR, "Couldn't open account confirmation temp file!");
    SEND_TO_Q
      ("&+YWarning: Could not send confirmation email, but you can still use the code displayed above.&n\r\n", d);
    return;
  }

  fprintf(f, "  *** Duris Account Confirmation Code ***\n\n\n");
  fprintf(f, "Your account confirmation code is:  %s\n", d->account->acct_confirmation);
  fclose(f);

  snprintf(b, 256, "mail -s \"%s\" %s < %s", "Duris Account Confirmation",
          d->account->acct_email, a);
  system(b);
  unlink(a);

  f = fopen(ACCOUNT_EMAIL_DB, "a");
  if (!f)
  {
    statuslog(56, "Couldn't open Email DB!");
  }
  else
  {
    fprintf(f, "%s\n", d->account->acct_email);
    fclose(f);
  }

  SEND_TO_Q("&+GAn email with your confirmation code has also been sent to your email address.&n\r\n", d);
#else
  // Email verification disabled - auto-confirm account
  SEND_TO_Q("&+G(Email verification is disabled - your account is automatically confirmed)&n\r\n", d);
  d->account->acct_confirmed = 1;
  write_account(d->account);
#endif

  return;
}

void display_account_information(P_desc d)
{
  char     buffer[4096];

  snprintf(buffer, 4096, "Account Name:              %s\r\n", d->account->acct_name);
  SEND_TO_Q(buffer, d);
  snprintf(buffer, 4096, "Email Address:             %s\r\n",
          d->account->acct_email);
  SEND_TO_Q(buffer, d);

}

char is_account_confirmed(P_desc d)
{
  if (d->account && d->account->acct_confirmed)
    return 1;
  else
    return 0;
}

void clear_account(P_acct acct)
{
  struct acct_ip *curr_ip = NULL;
  struct acct_ip *next_ip = NULL;
  struct acct_chars *curr_char = NULL;
  struct acct_chars *next_char = NULL;

  acct->acct_name = check_and_clear(acct->acct_name);
  acct->acct_email = check_and_clear(acct->acct_email);
  acct->acct_password = check_and_clear(acct->acct_password);
  acct->acct_confirmation = check_and_clear(acct->acct_confirmation);

  if (acct->acct_unique_ips)
  {
    for (curr_ip = acct->acct_unique_ips; curr_ip; curr_ip = next_ip)
    {
      curr_ip->hostname = check_and_clear(curr_ip->hostname);
      curr_ip->ip_address = check_and_clear(curr_ip->ip_address);
      next_ip = curr_ip->next;
      FREE(curr_ip);
    }
    acct->acct_unique_ips = NULL;
  }

  if (acct->acct_character_list)
  {
    for (curr_char = acct->acct_character_list; curr_char;
         curr_char = next_char)
    {
      curr_char->charname = check_and_clear(curr_char->charname);
      next_char = curr_char->next;
      FREE(curr_char);
    }
    acct->acct_character_list = NULL;
  }

  acct->acct_blocked = 0;
  acct->acct_confirmed = 0;
  acct->acct_confirmation_sent = 0;

  acct->acct_last = 0;
  acct->acct_good = 0;
  acct->acct_evil = 0;

  acct->acct_flags1 = 0;
  acct->acct_flags2 = 0;
  acct->acct_flags3 = 0;
  acct->acct_flags4 = 0;

  acct->next = NULL;
}

char    *check_and_clear(char *ptr)
{
  if (ptr)
    FREE(ptr);
  return NULL;
}

P_acct free_account(P_acct acct)
{
  if (acct)
  {
    remove_account_from_list(acct);
    clear_account(acct);
    FREE(acct);
  }
  return NULL;
}

P_acct allocate_account(void)
{
  P_acct   acct = NULL;


  CREATE(acct, acct_entry, 1, MEM_TAG_OTHER);

  if (!acct)
    raise(SIGSEGV);

  if (acct)
  {
    clear_account(acct);
    add_account_to_list(acct);
  }

  return acct;
}

void add_account_to_list(P_acct acct)
{
  P_acct   i = NULL;

  if (!acct)
    return;

  if (account_list == NULL)
  {
    account_list = acct;
    return;
  }
  else
  {
    acct->next = account_list;
    account_list = acct;
  }
}

void remove_account_from_list(P_acct acct)
{
  P_acct   i = NULL;

  if (!acct)
    return;

  i = account_list;
  if (i == acct)
  {
    account_list = i->next;
    return;
  }
  while (i && (i->next != acct))
  {
    i = i->next;
  }

  if (i)
  {
    i->next = acct->next;
  }
  return;
}

bool account_exists(const char *dir, char *name)
{
  char     buf[256], *buff;
  struct stat statbuf;
  char     Gbuf1[MAX_STRING_LENGTH];

  strcpy(buf, name);
  buff = buf;
  for (; *buff; buff++)
    *buff = LOWER(*buff);
  snprintf(Gbuf1, MAX_STRING_LENGTH, "%s/%c/%s", dir, buf[0], buf);
  if (stat(Gbuf1, &statbuf) != 0)
  {
    snprintf(Gbuf1, MAX_STRING_LENGTH, "%s/%c/%s", dir, buf[0], name);
    if (stat(Gbuf1, &statbuf) != 0)
      return FALSE;
  }
  return TRUE;
}
